#version 460

layout(local_size_x = 16, local_size_y = 16) in;

// ============================================================================
// FEATURE FLAGS - Toggle physical properties (compile-time, zero cost when off)
// ============================================================================
#define FEATURE_REFLECTION      1   // Mirror/metal reflection
#define FEATURE_REFRACTION      1   // Glass transmission
#define FEATURE_FRESNEL         1   // Fresnel blend at boundaries
#define FEATURE_SHADOWS         1   // Shadow rays for diffuse
#define FEATURE_ABSORPTION      1   // Beer's law colored glass
#define FEATURE_ROUGHNESS       1   // Glossy reflections (GGX)
// Floor is now scene-defined via push constants (pc.floorEnabled)
#define FEATURE_BUMP            1   // Normal perturbation (orange peel, hammered metal)
#define FEATURE_DISPERSION      0   // Chromatic aberration (TODO)
#define FEATURE_EMISSION        1   // Self-illuminating materials
#define FEATURE_ACCUMULATION    1   // Temporal accumulation (progressive refinement)
#define FEATURE_JITTER          1   // Subpixel jitter for anti-aliasing
#define FEATURE_CSG             1   // Interval-based CSG (analytic, exact edges)
#define FEATURE_AREA_LIGHTS     1   // Direct sampling of emissive surfaces (soft shadows)
#define FEATURE_POINT_LIGHTS    1   // Point light sources with distance falloff

#ifndef MAX_BOUNCES
#define MAX_BOUNCES             4   // Max ray depth (4-8 typical)
#endif
// ============================================================================

layout(rgba8, set = 0, binding = 0) uniform image2D outputImage;  // readwrite for accumulation

#if FEATURE_ACCUMULATION
layout(rgba32f, set = 0, binding = 5) uniform image2D accumImage;  // High precision accumulator
#endif

// Push constants
layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
    uint numPatches;
    uint numBVHNodes;
    vec3 camPos;
    uint frameIndex;
    vec3 camTarget;
    uint numInstances;
    uint numCSGPrimitives;
    uint numCSGNodes;
    uint numCSGRoots;
    uint numCSGBVHNodes;
    uint numMaterials;
    uint numLights;
    float sunAngularRadius;  // In radians
    uint floorEnabled;       // Scene-defined floor
    float floorY;            // Floor Y position
    uint floorMaterialId;    // Floor material index
    uint numEmissiveLights;  // Number of emissive area lights
} pc;

// Patch control points: 16 vec4s per patch (w unused, for alignment)
layout(std430, set = 0, binding = 1) readonly buffer PatchBuffer {
    vec4 patchData[];  // patchData[patchIndex * 16 + pointIndex]
};

// BVH nodes (64 bytes each, matching CPU struct)
struct BVHNode {
    float minX, minY, minZ;
    uint leftOrFirst;   // Left child index, or first patch index if leaf
    float maxX, maxY, maxZ;
    uint rightOrCount;  // Right child index, or patch count if leaf (high bit = leaf flag)
};

layout(std430, set = 0, binding = 2) readonly buffer BVHBuffer {
    BVHNode bvhNodes[];
};

// Patch indices (reordered by BVH build)
layout(std430, set = 0, binding = 3) readonly buffer PatchIndexBuffer {
    uint patchIndices[];
};

// Instance data (must match CPU struct)
struct BezierInstance {
    vec3 position;
    float scale;
    vec3 rotation;  // Euler angles (radians), applied in XYZ order
    uint materialId;
};

layout(std430, set = 0, binding = 4) readonly buffer InstanceBuffer {
    BezierInstance instances[];
};

// CSG primitive data (must match CPU struct)
struct CSGPrimitive {
    float x, y, z;          // center
    uint type;              // 0=sphere, 1=box, 2=cylinder, 3=cone, 4=torus
    float param0;           // sphere: radius, box: halfX, cyl/cone: radius, torus: majorR
    float param1;           // box: halfY, cyl/cone: height, torus: minorR
    float param2;           // box: halfZ
    float _pad;
};

// CSG node data (must match CPU struct)
struct CSGNode {
    uint type;              // 0=primitive, 1=union, 2=intersect, 3=subtract
    uint left;              // primitive index (type=0) or left child node index
    uint right;             // right child node index (unused for type=0)
    uint materialId;
};

layout(std430, set = 0, binding = 6) readonly buffer CSGPrimitiveBuffer {
    CSGPrimitive csgPrimitives[];
};

layout(std430, set = 0, binding = 7) readonly buffer CSGNodeBuffer {
    CSGNode csgNodes[];
};

layout(std430, set = 0, binding = 8) readonly buffer CSGRootBuffer {
    uint csgRoots[];
};

// Material data (must match CPU struct)
struct Material {
    float r, g, b;          // albedo
    uint type;              // 0=diffuse, 1=metal, 2=glass, 3=emissive
    float roughness;        // 0=mirror, 1=matte
    float metallic;         // 0=dielectric, 1=conductor
    float ior;              // index of refraction
    float emissive;         // emission multiplier
};

layout(std430, set = 0, binding = 9) readonly buffer MaterialBuffer {
    Material materials[];
};

// CSG BVH node (must match CPU CSGBVHNode struct)
struct CSGBVHNode {
    float minX, minY, minZ;
    uint leftOrFirst;   // Left child index, or first root index if leaf
    float maxX, maxY, maxZ;
    uint rightOrCount;  // Right child index, or root count if leaf (high bit = leaf flag)
};

layout(std430, set = 0, binding = 10) readonly buffer CSGBVHBuffer {
    CSGBVHNode csgBVHNodes[];
};

// Light data (must match CPU struct)
// Type: 0=Directional (sun), 1=Point
struct Light {
    vec3 direction;     // Direction (directional) or position (point)
    uint type;
    vec3 color;
    float intensity;
};

layout(std430, set = 0, binding = 11) readonly buffer LightBuffer {
    Light lights[];     // lights[0] is always the sun
};

// Emissive area light (from CSG primitive with emissive material)
struct EmissiveLight {
    uint primitiveIndex;  // Index into CSGPrimitive buffer
    uint nodeIndex;       // Index into CSGNode buffer (for material lookup)
    float area;           // Surface area for PDF calculation
    float _pad;
};

layout(std430, set = 0, binding = 12) readonly buffer EmissiveLightBuffer {
    EmissiveLight emissiveLights[];
};

// Light type constants
#define LIGHT_DIRECTIONAL  0
#define LIGHT_POINT        1

// Material type constants
#define MAT_DIFFUSE   0
#define MAT_METAL     1
#define MAT_GLASS     2
#define MAT_EMISSIVE  3
#define MAT_CHECKER   4

// CSG node type constants
#define CSG_NODE_PRIMITIVE  0
#define CSG_NODE_UNION      1
#define CSG_NODE_INTERSECT  2
#define CSG_NODE_SUBTRACT   3

// CSG primitive type constants
#define CSG_PRIM_SPHERE     0
#define CSG_PRIM_BOX        1
#define CSG_PRIM_CYLINDER   2
#define CSG_PRIM_CONE       3
#define CSG_PRIM_TORUS      4

// ============================================================================
// CONSTANTS
// ============================================================================
const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float T_MAX = 1000.0;

// ============================================================================
// LIBRARY INCLUDES
// ============================================================================
#include "includes/random.glsl"

#if FEATURE_BUMP
#include "includes/noise.glsl"
#endif

#if FEATURE_ROUGHNESS || FEATURE_FRESNEL
#include "includes/materials.glsl"
#endif

#include "includes/geometry.glsl"
#include "includes/sampling.glsl"

// ============================================================================
// AREA LIGHT SAMPLING (Direct lighting from emissive objects)
// Forward declarations - implementations after hitCSG and hitAllInstances
// ============================================================================
#if FEATURE_AREA_LIGHTS
bool inShadowAreaLight(vec3 origin, vec3 dir, float maxDist);
vec3 sampleEmissiveLights(vec3 hitPoint, vec3 normal, vec3 albedo);
#endif

#if FEATURE_POINT_LIGHTS
vec3 evaluatePointLights(vec3 hitPoint, vec3 normal, vec3 albedo);
#endif

// Newton iteration tuning
#define NEWTON_MAX_ITER 6  // Base iterations (used for first frames)
#include "includes/bezier.glsl"

// Interval-based CSG (exact analytic edges)
#if FEATURE_CSG
#include "includes/csg.glsl"

// Get interval for a CSG primitive by index
Interval getPrimitiveInterval(vec3 ro, vec3 rd, uint primIndex) {
    CSGPrimitive prim = csgPrimitives[primIndex];
    vec3 center = vec3(prim.x, prim.y, prim.z);

    switch (prim.type) {
        case CSG_PRIM_SPHERE:
            return raySphere(ro, rd, center, prim.param0);
        case CSG_PRIM_BOX:
            return rayBox(ro, rd, center, vec3(prim.param0, prim.param1, prim.param2));
        case CSG_PRIM_CYLINDER:
            return rayCylinder(ro, rd, center, prim.param0, prim.param1);
        case CSG_PRIM_CONE:
            return rayCone(ro, rd, center, prim.param0, prim.param1);
        case CSG_PRIM_TORUS:
            return rayTorus(ro, rd, center, prim.param0, prim.param1);
        default:
            return EMPTY_INTERVAL;
    }
}

// Stack-based CSG tree evaluation using iterative post-order traversal
// Returns the interval for a given node index
const int CSG_STACK_SIZE = 32;

Interval evaluateCSGNode(vec3 ro, vec3 rd, uint nodeIndex) {
    // Stack for traversal: stores (nodeIndex, visitState)
    // visitState: 0 = first visit, 1 = left done, 2 = right done (ready to process)
    uint traverseStack[CSG_STACK_SIZE];
    uint stateStack[CSG_STACK_SIZE];
    int traversePtr = 0;

    // Result stack for computed intervals
    Interval resultStack[CSG_STACK_SIZE];
    int resultPtr = 0;

    // Start with root node
    traverseStack[traversePtr] = nodeIndex;
    stateStack[traversePtr] = 0;
    traversePtr++;

    while (traversePtr > 0) {
        uint idx = traverseStack[traversePtr - 1];
        uint state = stateStack[traversePtr - 1];
        CSGNode node = csgNodes[idx];

        if (node.type == CSG_NODE_PRIMITIVE) {
            // Leaf node - compute interval and push to results
            if (resultPtr >= CSG_STACK_SIZE) return EMPTY_INTERVAL;  // Result stack overflow
            resultStack[resultPtr++] = getPrimitiveInterval(ro, rd, node.left);
            traversePtr--;  // Pop this node
        } else {
            // Operation node - need to process children first
            if (state == 0) {
                // First visit - push left child
                if (traversePtr >= CSG_STACK_SIZE) return EMPTY_INTERVAL;  // Stack overflow
                stateStack[traversePtr - 1] = 1;
                traverseStack[traversePtr] = node.left;
                stateStack[traversePtr] = 0;
                traversePtr++;
            } else if (state == 1) {
                // Left child done - push right child
                if (traversePtr >= CSG_STACK_SIZE) return EMPTY_INTERVAL;  // Stack overflow
                stateStack[traversePtr - 1] = 2;
                traverseStack[traversePtr] = node.right;
                stateStack[traversePtr] = 0;
                traversePtr++;
            } else {
                // Both children done - combine their intervals
                Interval right = resultStack[--resultPtr];
                Interval left = resultStack[--resultPtr];

                Interval result;
                if (node.type == CSG_NODE_UNION) {
                    result = opUnion(left, right);
                } else if (node.type == CSG_NODE_INTERSECT) {
                    result = opIntersect(left, right);
                } else if (node.type == CSG_NODE_SUBTRACT) {
                    result = opSubtract(left, right);
                } else {
                    result = EMPTY_INTERVAL;
                }

                if (resultPtr >= CSG_STACK_SIZE) return EMPTY_INTERVAL;  // Result stack overflow
                resultStack[resultPtr++] = result;
                traversePtr--;  // Pop this node
            }
        }
    }

    return (resultPtr > 0) ? resultStack[0] : EMPTY_INTERVAL;
}

// CSG BVH helper functions
bool isCSGBVHLeaf(uint nodeIdx) {
    return (csgBVHNodes[nodeIdx].rightOrCount & 0x80000000u) != 0u;
}

uint csgBVHRootCount(uint nodeIdx) {
    return csgBVHNodes[nodeIdx].rightOrCount & 0x7FFFFFFFu;
}

// CSG scene evaluation from buffers with BVH acceleration
// Returns material ID via outMat
bool hitCSG(vec3 ro, vec3 rd, float tMin, float tMax, out float hitT, out vec3 hitN, out int outMat) {
    float closestT = tMax;
    bool hit = false;

    // If no BVH, fall back to linear iteration
    if (pc.numCSGBVHNodes == 0) {
        for (uint i = 0; i < pc.numCSGRoots; i++) {
            uint rootNodeIndex = csgRoots[i];
            CSGNode rootNode = csgNodes[rootNodeIndex];

            Interval interval = evaluateCSGNode(ro, rd, rootNodeIndex);

            float t;
            vec3 n;
            if (firstHit(interval, tMin, closestT, t, n)) {
                closestT = t;
                hitT = t;
                hitN = n;
                outMat = int(rootNode.materialId);
                hit = true;
            }
        }
        return hit;
    }

    // BVH traversal stack
    uint stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;  // Start with root node

    while (stackPtr > 0) {
        uint nodeIdx = stack[--stackPtr];
        CSGBVHNode node = csgBVHNodes[nodeIdx];

        vec3 aabbMin = vec3(node.minX, node.minY, node.minZ);
        vec3 aabbMax = vec3(node.maxX, node.maxY, node.maxZ);

        // Skip if ray doesn't hit this node's AABB
        if (!hitAABB(aabbMin, aabbMax, ro, rd, tMin, closestT)) {
            continue;
        }

        if (isCSGBVHLeaf(nodeIdx)) {
            // Leaf node - test all roots in this leaf
            uint first = node.leftOrFirst;
            uint count = csgBVHRootCount(nodeIdx);

            for (uint i = 0; i < count; i++) {
                uint rootNodeIndex = csgRoots[first + i];
                CSGNode rootNode = csgNodes[rootNodeIndex];

                Interval interval = evaluateCSGNode(ro, rd, rootNodeIndex);

                float t;
                vec3 n;
                if (firstHit(interval, tMin, closestT, t, n)) {
                    closestT = t;
                    hitT = t;
                    hitN = n;
                    outMat = int(rootNode.materialId);
                    hit = true;
                }
            }
        } else {
            // Internal node - push children
            stack[stackPtr++] = node.rightOrCount;
            stack[stackPtr++] = node.leftOrFirst;
        }
    }

    return hit;
}
#endif

// ============================================================================
// ROTATION FUNCTIONS (for instance transforms)
// ============================================================================
vec3 rotateX(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(v.x, c * v.y - s * v.z, s * v.y + c * v.z);
}

vec3 rotateY(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(c * v.x + s * v.z, v.y, -s * v.x + c * v.z);
}

vec3 rotateZ(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(c * v.x - s * v.y, s * v.x + c * v.y, v.z);
}

vec3 rotateXYZ(vec3 v, vec3 angles) {
    return rotateZ(rotateY(rotateX(v, angles.x), angles.y), angles.z);
}

vec3 rotateXYZInverse(vec3 v, vec3 angles) {
    return rotateX(rotateY(rotateZ(v, -angles.z), -angles.y), -angles.x);
}

// ============================================================================
// CAMERA
// ============================================================================
struct Ray {
    vec3 origin;
    vec3 direction;
};

Ray getCameraRay(vec2 uv, vec2 jitter) {
    vec3 forward = normalize(pc.camTarget - pc.camPos);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = cross(right, forward);

    // Apply subpixel jitter for anti-aliasing
    vec2 jitteredUV = uv + jitter / vec2(pc.width, pc.height);

    float aspect = float(pc.width) / float(pc.height);
    float fov = 0.8;
    vec3 dir = normalize(forward + (jitteredUV.x - 0.5) * fov * aspect * right + (jitteredUV.y - 0.5) * fov * up);

    return Ray(pc.camPos, dir);
}

// ============================================================================
// BVH TRAVERSAL
// ============================================================================
bool isLeaf(uint nodeIdx) {
    return (bvhNodes[nodeIdx].rightOrCount & 0x80000000u) != 0u;
}

uint patchCount(uint nodeIdx) {
    return bvhNodes[nodeIdx].rightOrCount & 0x7FFFFFFFu;
}

bool hitInstance(Ray localRay, float tMin, float tMax,
                 out float hitT, out vec3 hitN, out float hitU, out float hitV) {
    bool hit = false;
    float closestT = tMax;

    uint stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        uint nodeIdx = stack[--stackPtr];
        BVHNode node = bvhNodes[nodeIdx];

        vec3 aabbMin = vec3(node.minX, node.minY, node.minZ);
        vec3 aabbMax = vec3(node.maxX, node.maxY, node.maxZ);

        if (!hitAABB(aabbMin, aabbMax, localRay.origin, localRay.direction, tMin, closestT)) {
            continue;
        }

        if (isLeaf(nodeIdx)) {
            uint first = node.leftOrFirst;
            uint count = patchCount(nodeIdx);

            for (uint i = 0; i < count; i++) {
                uint patchIdx = patchIndices[first + i];

                vec3 cp[16];
                for (int j = 0; j < 16; j++) {
                    cp[j] = patchData[patchIdx * 16 + j].xyz;
                }

                float t, u, v;
                vec3 n;
                if (hitBezierPatch(cp, localRay.origin, localRay.direction, tMin, closestT, t, u, v, n)) {
                    hit = true;
                    closestT = t;
                    hitT = t;
                    hitN = n;
                    hitU = u;
                    hitV = v;
                }
            }
        } else {
            stack[stackPtr++] = node.rightOrCount;
            stack[stackPtr++] = node.leftOrFirst;
        }
    }

    return hit;
}

bool hitAllInstances(Ray worldRay, float tMin, float tMax,
                     out float hitT, out vec3 hitN, out uint hitInstanceId) {
    bool hit = false;
    float closestT = tMax;

    for (uint i = 0; i < pc.numInstances; i++) {
        BezierInstance inst = instances[i];

        Ray localRay;
        vec3 translated = worldRay.origin - inst.position;
        localRay.origin = rotateXYZInverse(translated, inst.rotation) / inst.scale;
        localRay.direction = rotateXYZInverse(worldRay.direction, inst.rotation);

        float localTMax = closestT / inst.scale;

        float t, u, v;
        vec3 n;
        if (hitInstance(localRay, tMin / inst.scale, localTMax, t, n, u, v)) {
            float worldT = t * inst.scale;
            if (worldT < closestT) {
                hit = true;
                closestT = worldT;
                hitT = worldT;
                hitN = rotateXYZ(n, inst.rotation);
                hitInstanceId = i;
            }
        }
    }

    return hit;
}

// ============================================================================
// AREA LIGHT SAMPLING IMPLEMENTATION
// ============================================================================
#if FEATURE_AREA_LIGHTS

// Shadow test for area lights - returns true if point is in shadow
bool inShadowAreaLight(vec3 origin, vec3 dir, float maxDist) {
    // Test against Bezier instances
    float shadowT;
    vec3 shadowN;
    uint shadowId;
    if (hitAllInstances(Ray(origin, dir), EPSILON, maxDist, shadowT, shadowN, shadowId)) {
        return true;
    }

#if FEATURE_CSG
    // Test against CSG objects
    int shadowMat;
    float csgShadowT;
    vec3 csgShadowN;
    if (hitCSG(origin, dir, EPSILON, maxDist, csgShadowT, csgShadowN, shadowMat)) {
        // Don't count the emissive object itself as blocking (it IS the light)
        Material mat = materials[shadowMat];
        if (mat.type != MAT_EMISSIVE) {
            return true;
        }
    }
#endif

    return false;
}

// Sample direct lighting contribution from all emissive area lights
vec3 sampleEmissiveLights(vec3 hitPoint, vec3 normal, vec3 albedo) {
    if (pc.numEmissiveLights == 0) return vec3(0.0);

    vec3 result = vec3(0.0);

    for (uint i = 0; i < pc.numEmissiveLights; i++) {
        EmissiveLight eLight = emissiveLights[i];

        // Sample a point on the emissive surface
        vec3 lightNormal;
        float pdf;
        vec3 lightPos = sampleEmissivePrimitive(eLight.primitiveIndex, lightNormal, pdf, eLight.area);

        // Direction from hit point to light sample
        vec3 toLight = lightPos - hitPoint;
        float dist = length(toLight);
        vec3 lightDir = toLight / dist;

        // Check if light is on correct side of both surfaces
        float NdotL = dot(normal, lightDir);
        float LNdotL = dot(-lightNormal, lightDir);  // Light normal faces outward

        if (NdotL <= 0.0 || LNdotL <= 0.0) continue;

        // Geometry term: accounts for projected areas and distance falloff
        float G = NdotL * LNdotL / (dist * dist);

        // Shadow test
        vec3 shadowOrigin = hitPoint + normal * EPSILON * 2.0;
        if (inShadowAreaLight(shadowOrigin, lightDir, dist - EPSILON * 4.0)) {
            continue;
        }

        // Get emissive material properties
        CSGNode node = csgNodes[eLight.nodeIndex];
        Material mat = materials[node.materialId];
        vec3 emissiveColor = vec3(mat.r, mat.g, mat.b) * mat.emissive;

        // Direct lighting contribution: Le * BRDF * G / pdf
        // For Lambert BRDF: albedo / PI
        // Result: emissiveColor * (albedo / PI) * G / pdf
        result += emissiveColor * albedo * G / (PI * pdf);
    }

    return result;
}

#endif  // FEATURE_AREA_LIGHTS

// ============================================================================
// POINT LIGHT EVALUATION
// ============================================================================
#if FEATURE_POINT_LIGHTS

// Evaluate contribution from all point lights
vec3 evaluatePointLights(vec3 hitPoint, vec3 normal, vec3 albedo) {
    vec3 result = vec3(0.0);

    // Iterate through all lights (skip lights[0] which is the sun)
    for (uint i = 1; i < pc.numLights; i++) {
        Light light = lights[i];
        if (light.type != LIGHT_POINT) continue;

        // Direction and distance to light
        vec3 lightPos = light.direction;  // For point lights, direction field holds position
        vec3 toLight = lightPos - hitPoint;
        float dist = length(toLight);
        vec3 lightDir = toLight / dist;

        // Check if light is on correct side of surface
        float NdotL = dot(normal, lightDir);
        if (NdotL <= 0.0) continue;

        // Distance attenuation (inverse square law)
        float attenuation = 1.0 / (dist * dist);

        // Shadow test
        vec3 shadowOrigin = hitPoint + normal * EPSILON * 2.0;
        bool inShadow = false;

#if FEATURE_SHADOWS
        float shadowT;
        vec3 shadowN;
        uint shadowId;
        if (hitAllInstances(Ray(shadowOrigin, lightDir), EPSILON, dist - EPSILON * 2.0, shadowT, shadowN, shadowId)) {
            inShadow = true;
        }
#if FEATURE_CSG
        if (!inShadow) {
            int shadowMat;
            float csgShadowT;
            vec3 csgShadowN;
            if (hitCSG(shadowOrigin, lightDir, EPSILON, dist - EPSILON * 2.0, csgShadowT, csgShadowN, shadowMat)) {
                inShadow = true;
            }
        }
#endif
#endif

        if (inShadow) continue;

        // Light color and intensity
        vec3 lightColor = light.color * light.intensity;

        // Lambertian contribution
        result += albedo * lightColor * NdotL * attenuation;
    }

    return result;
}

#endif  // FEATURE_POINT_LIGHTS

// ============================================================================
// MATERIAL TYPES
// ============================================================================
#define MAT_DIFFUSE  0
#define MAT_METAL    1
#define MAT_GLASS    2
#define MAT_EMISSIVE 3

// ============================================================================
// MAIN RENDER LOOP
// ============================================================================
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pc.width) || pixel.y >= int(pc.height)) return;

    // Initialize RNG - use frame index for temporal variation when accumulating
#if FEATURE_ACCUMULATION
    initRNGTemporal(pixel, pc.frameIndex);
    // Adaptive iterations: more for first frames, fewer once accumulating
    g_newtonMaxIter = (pc.frameIndex < 4) ? NEWTON_MAX_ITER : 4;
#else
    initRNG(pixel);
#endif

    vec2 uv = vec2(pixel) / vec2(pc.width, pc.height);
    uv.y = 1.0 - uv.y;

    // Subpixel jitter for anti-aliasing
#if FEATURE_JITTER
    vec2 jitter = vec2(rand() - 0.5, rand() - 0.5);
#else
    vec2 jitter = vec2(0.0);
#endif

    Ray ray = getCameraRay(uv, jitter);
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0);

    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
        float t;
        vec3 normal;
        uint instanceId;
        bool hitFloorFlag = false;
#if FEATURE_CSG
        bool hitCSGFlag = false;
        int csgMatId = 0;
#endif

        bool hitBezier = hitAllInstances(ray, EPSILON, T_MAX, t, normal, instanceId);

#if FEATURE_CSG
        // CSG object test (interval-based, exact edges)
        float csgT;
        vec3 csgN;
        int csgMat;
        float tMaxCSG = hitBezier ? t : T_MAX;
        if (hitCSG(ray.origin, ray.direction, EPSILON, tMaxCSG, csgT, csgN, csgMat)) {
            t = csgT;
            normal = csgN;
            hitCSGFlag = true;
            csgMatId = csgMat;
            hitBezier = false;
        }
#endif

        // Scene-defined floor (runtime check)
        if (pc.floorEnabled != 0u) {
            float floorT;
            vec3 floorN;
#if FEATURE_CSG
            float tMaxFloor = (hitBezier || hitCSGFlag) ? t : T_MAX;
#else
            float tMaxFloor = hitBezier ? t : T_MAX;
#endif
            if (hitFloorPlane(ray.origin, ray.direction, pc.floorY, EPSILON, tMaxFloor, floorT, floorN)) {
                t = floorT;
                normal = floorN;
                hitFloorFlag = true;
                hitBezier = false;
#if FEATURE_CSG
                hitCSGFlag = false;
#endif
            }
        }

#if FEATURE_CSG
        if (!hitBezier && !hitFloorFlag && !hitCSGFlag) {
#else
        if (!hitBezier && !hitFloorFlag) {
#endif
            color += throughput * skyGradient(ray.direction);
            break;
        }

        vec3 hitPoint = ray.origin + t * ray.direction;

        // Floor material (scene-defined)
        if (hitFloorFlag) {
            Material floorMat = materials[pc.floorMaterialId];
            vec3 color1 = vec3(floorMat.r, floorMat.g, floorMat.b);
            vec3 floorColor;

            if (floorMat.type == MAT_CHECKER) {
                // Checker: color2 in roughness/metallic/ior, scale in emissive
                vec3 color2 = vec3(floorMat.roughness, floorMat.metallic, floorMat.ior);
                float scale = floorMat.emissive;
                floorColor = checkerPattern(hitPoint, scale, color1, color2);
            } else {
                floorColor = color1;
            }

            vec3 lightDir = normalize(lights[0].direction);
            vec3 lightCol = lights[0].color * lights[0].intensity;
            float NdotL = max(dot(normal, lightDir), 0.0);

            float shadow = 1.0;
#if FEATURE_SHADOWS
            float shadowT;
            vec3 shadowN;
            uint shadowId;
            vec3 shadowOrigin = hitPoint + normal * EPSILON * 2.0;
            if (hitAllInstances(Ray(shadowOrigin, lightDir),
                                EPSILON, T_MAX, shadowT, shadowN, shadowId)) {
                shadow = 0.3;
            }
#if FEATURE_CSG
            int shadowMat;
            float csgShadowT;
            vec3 csgShadowN;
            if (hitCSG(shadowOrigin, lightDir, EPSILON, T_MAX, csgShadowT, csgShadowN, shadowMat)) {
                shadow = 0.3;
            }
#endif
#endif
            // Apply sun color to lit portion
            vec3 ambient = floorColor * 0.15;
            vec3 diffuse = floorColor * lightCol * NdotL * shadow * 0.85;

            vec3 extraLight = vec3(0.0);
#if FEATURE_AREA_LIGHTS
            extraLight += sampleEmissiveLights(hitPoint, normal, floorColor);
#endif
#if FEATURE_POINT_LIGHTS
            extraLight += evaluatePointLights(hitPoint, normal, floorColor);
#endif
            color += throughput * (ambient + diffuse + extraLight);
            break;
        }

#if FEATURE_CSG
        // CSG object materials - lookup from buffer
        if (hitCSGFlag) {
            Material mat = materials[csgMatId];
            vec3 matColor = vec3(mat.r, mat.g, mat.b);

#if FEATURE_EMISSION
            if (mat.type == MAT_EMISSIVE) {
                // Emissive material - add light contribution and terminate
                color += throughput * matColor * mat.emissive;
                break;
            }
#endif
            if (mat.type == MAT_GLASS) {
                // Glass material - refraction with IOR from material
                float cosTheta = dot(-ray.direction, normal);
                bool entering = cosTheta > 0.0;
                vec3 n = entering ? normal : -normal;
                float eta = entering ? (1.0 / mat.ior) : mat.ior;

                vec3 refracted = refract(ray.direction, n, eta);
                if (length(refracted) < 0.5) {
                    ray.origin = hitPoint + n * EPSILON * 2.0;
                    ray.direction = reflect(ray.direction, n);
                } else {
                    ray.origin = hitPoint - n * EPSILON * 2.0;
                    ray.direction = refracted;
                }
                throughput *= matColor;
            } else if (mat.type == MAT_METAL) {
                // Metal reflection with optional roughness
                ray.origin = hitPoint + normal * EPSILON * 2.0;
#if FEATURE_ROUGHNESS
                if (mat.roughness > 0.001) {
                    vec3 H = sampleGGX(normal, mat.roughness);
                    ray.direction = reflect(ray.direction, H);
                    if (dot(ray.direction, normal) < 0.0) {
                        ray.direction = reflect(ray.direction, normal);
                    }
                } else {
                    ray.direction = reflect(ray.direction, normal);
                }
#else
                ray.direction = reflect(ray.direction, normal);
#endif
                throughput *= matColor;
            } else {
                // Diffuse - simple Lambert with dynamic sun
                vec3 lightDir = normalize(lights[0].direction);
                vec3 lightCol = lights[0].color * lights[0].intensity;
                float NdotL = max(dot(normal, lightDir), 0.0);
                vec3 ambient = matColor * 0.15;
                vec3 diffuse = matColor * lightCol * NdotL * 0.85;

                vec3 extraLight = vec3(0.0);
#if FEATURE_AREA_LIGHTS
                extraLight += sampleEmissiveLights(hitPoint, normal, matColor);
#endif
#if FEATURE_POINT_LIGHTS
                extraLight += evaluatePointLights(hitPoint, normal, matColor);
#endif
                color += throughput * (ambient + diffuse + extraLight);
                break;
            }
            continue;  // Bounce
        }
#endif

        // Look up material from buffer using instance's materialId
        BezierInstance inst = instances[instanceId];
        Material mat = materials[inst.materialId];
        uint matType = mat.type;
        vec3 baseColor = vec3(mat.r, mat.g, mat.b);


#if FEATURE_BUMP
        // Bump mapping for rough metals (metallic field encodes bump strength)
        if (matType == MAT_METAL && mat.metallic > 0.0) {
            float bumpStrength = mat.metallic;
            float bumpScale = 25.0;  // Fixed scale for hammered effect
            normal = bumpNormal(hitPoint, normal, bumpScale, bumpStrength);
        }
#endif

        // ----- DIFFUSE -----
        if (matType == MAT_DIFFUSE) {
            vec3 lightDir = normalize(lights[0].direction);
            vec3 lightCol = lights[0].color * lights[0].intensity;
            float NdotL = max(dot(normal, lightDir), 0.0);

            float shadow = 1.0;
#if FEATURE_SHADOWS
            float shadowT;
            vec3 shadowN;
            uint shadowId;
            vec3 shadowOrigin = hitPoint + normal * EPSILON * 2.0;
            if (hitAllInstances(Ray(shadowOrigin, lightDir),
                                EPSILON, T_MAX, shadowT, shadowN, shadowId)) {
                shadow = 0.3;
            }
#if FEATURE_CSG
            int shadowMat;
            float csgShadowT;
            vec3 csgShadowN;
            if (hitCSG(shadowOrigin, lightDir, EPSILON, T_MAX, csgShadowT, csgShadowN, shadowMat)) {
                shadow = 0.3;
            }
#endif
#endif
            vec3 ambient = baseColor * 0.15;
            vec3 diffuse = baseColor * lightCol * NdotL * shadow * 0.85;

            vec3 extraLight = vec3(0.0);
#if FEATURE_AREA_LIGHTS
            extraLight += sampleEmissiveLights(hitPoint, normal, baseColor);
#endif
#if FEATURE_POINT_LIGHTS
            extraLight += evaluatePointLights(hitPoint, normal, baseColor);
#endif
            color += throughput * (ambient + diffuse + extraLight);
            break;
        }

        // ----- METAL -----
#if FEATURE_REFLECTION
        else if (matType == MAT_METAL) {
            ray.origin = hitPoint + normal * EPSILON * 2.0;

#if FEATURE_ROUGHNESS
            if (mat.roughness > 0.001) {
                vec3 H = sampleGGX(normal, mat.roughness);
                ray.direction = reflect(ray.direction, H);
                if (dot(ray.direction, normal) < 0.0) {
                    ray.direction = reflect(ray.direction, normal);
                }
            } else {
                ray.direction = reflect(ray.direction, normal);
            }
#else
            ray.direction = reflect(ray.direction, normal);
#endif
            throughput *= baseColor;
        }
#endif

        // ----- GLASS -----
#if FEATURE_REFRACTION
        else if (matType == MAT_GLASS) {
            float cosTheta = dot(-ray.direction, normal);
            bool entering = cosTheta > 0.0;

            vec3 n = entering ? normal : -normal;
            float eta = entering ? (1.0 / mat.ior) : mat.ior;
            cosTheta = abs(cosTheta);

#if FEATURE_ABSORPTION
            if (!entering) {
                // Derive absorption from inverse of color (darker = more absorption)
                vec3 absorptionCoeff = -log(max(baseColor, vec3(0.01))) * 0.5;
                throughput *= exp(-absorptionCoeff * t);
            }
#endif

#if FEATURE_FRESNEL
            float F = fresnel(cosTheta, mat.ior);
            bool doReflect = (F > 0.5);
#else
            bool doReflect = false;
#endif

            if (doReflect) {
                ray.origin = hitPoint + n * EPSILON * 2.0;
                ray.direction = reflect(ray.direction, n);
            } else {
                vec3 refracted = refract(ray.direction, n, eta);
                if (length(refracted) < 0.5) {
                    ray.origin = hitPoint + n * EPSILON * 2.0;
                    ray.direction = reflect(ray.direction, n);
                } else {
                    ray.origin = hitPoint - n * EPSILON * 2.0;
                    ray.direction = refracted;
                }
            }
            throughput *= baseColor;
        }
#endif

        // ----- EMISSIVE -----
#if FEATURE_EMISSION
        else if (matType == MAT_EMISSIVE) {
            color += throughput * baseColor * mat.emissive;
            break;
        }
#endif
    }

    // Accumulation blending (in linear space, before gamma)
#if FEATURE_ACCUMULATION
    if (pc.frameIndex > 0) {
        vec3 accumColor = imageLoad(accumImage, pixel).rgb;
        float weight = 1.0 / float(pc.frameIndex + 1);
        color = mix(accumColor, color, weight);
    }
    imageStore(accumImage, pixel, vec4(color, 1.0));
#endif

    // Gamma correction for display
    vec3 displayColor = pow(clamp(color, 0.0, 1.0), vec3(1.0 / 2.2));
    imageStore(outputImage, pixel, vec4(displayColor, 1.0));
}
