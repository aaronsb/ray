#version 460

layout(local_size_x = 16, local_size_y = 16) in;

// ============================================================================
// FEATURE FLAGS - Toggle physical properties (compile-time, zero cost when off)
// ============================================================================
#define FEATURE_REFLECTION      1   // Mirror/metal reflection
#define FEATURE_REFRACTION      1   // Glass transmission
#define FEATURE_FRESNEL         1   // Fresnel blend at boundaries
#define FEATURE_SHADOWS         1   // Shadow rays for diffuse
#define FEATURE_ABSORPTION      1   // Beer's law colored glass
#define FEATURE_ROUGHNESS       1   // Glossy reflections (GGX)
#define FEATURE_FLOOR           1   // Checker floor plane
#define FEATURE_BUMP            1   // Normal perturbation (orange peel, hammered metal)
#define FEATURE_DISPERSION      0   // Chromatic aberration (TODO)
#define FEATURE_EMISSION        0   // Self-illuminating materials (TODO)
#define FEATURE_ACCUMULATION    1   // Temporal accumulation (progressive refinement)
#define FEATURE_JITTER          1   // Subpixel jitter for anti-aliasing
#define FEATURE_CSG             1   // Interval-based CSG (analytic, exact edges)

#ifndef MAX_BOUNCES
#define MAX_BOUNCES             4   // Max ray depth (4-8 typical)
#endif
// ============================================================================

layout(rgba8, set = 0, binding = 0) uniform image2D outputImage;  // readwrite for accumulation

#if FEATURE_ACCUMULATION
layout(rgba32f, set = 0, binding = 5) uniform image2D accumImage;  // High precision accumulator
#endif

// Push constants
layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
    uint numPatches;
    uint numBVHNodes;
    vec3 camPos;
    uint frameIndex;
    vec3 camTarget;
    uint numInstances;
} pc;

// Patch control points: 16 vec4s per patch (w unused, for alignment)
layout(std430, set = 0, binding = 1) readonly buffer PatchBuffer {
    vec4 patchData[];  // patchData[patchIndex * 16 + pointIndex]
};

// BVH nodes (64 bytes each, matching CPU struct)
struct BVHNode {
    float minX, minY, minZ;
    uint leftOrFirst;   // Left child index, or first patch index if leaf
    float maxX, maxY, maxZ;
    uint rightOrCount;  // Right child index, or patch count if leaf (high bit = leaf flag)
};

layout(std430, set = 0, binding = 2) readonly buffer BVHBuffer {
    BVHNode bvhNodes[];
};

// Patch indices (reordered by BVH build)
layout(std430, set = 0, binding = 3) readonly buffer PatchIndexBuffer {
    uint patchIndices[];
};

// Instance data (must match CPU struct)
struct BezierInstance {
    vec3 position;
    float scale;
    vec3 rotation;  // Euler angles (radians), applied in XYZ order
    uint materialId;
};

layout(std430, set = 0, binding = 4) readonly buffer InstanceBuffer {
    BezierInstance instances[];
};

// ============================================================================
// CONSTANTS
// ============================================================================
const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float T_MAX = 1000.0;

// ============================================================================
// LIBRARY INCLUDES
// ============================================================================
#include "includes/random.glsl"

#if FEATURE_BUMP
#include "includes/noise.glsl"
#endif

#if FEATURE_ROUGHNESS || FEATURE_FRESNEL
#include "includes/materials.glsl"
#endif

#include "includes/geometry.glsl"

// Newton iteration tuning
#define NEWTON_MAX_ITER 6  // Base iterations (used for first frames)
#include "includes/bezier.glsl"

// Interval-based CSG (exact analytic edges)
#if FEATURE_CSG
#include "includes/csg.glsl"

// Material IDs for CSG objects
#define CSG_MAT_RED     0
#define CSG_MAT_GREEN   1
#define CSG_MAT_BLUE    2
#define CSG_MAT_GOLD    3
#define CSG_MAT_SILVER  4
#define CSG_MAT_GLASS   5

// CSG scene: showcase of primitives and combinations
// Returns material ID via outMat
bool hitCSG(vec3 ro, vec3 rd, float tMin, float tMax, out float hitT, out vec3 hitN, out int outMat) {
    Interval closest = EMPTY_INTERVAL;
    int closestMat = 0;
    float closestT = tMax;

    // Helper macro to test an interval and track closest
    #define TEST_INTERVAL(interval, mat) { \
        float t; vec3 n; \
        if (firstHit(interval, tMin, closestT, t, n)) { \
            closestT = t; \
            hitT = t; \
            hitN = n; \
            outMat = mat; \
        } \
    }

    // ========================================
    // Row 1 (z = 6): Plain primitives
    // ========================================

    // Sphere
    TEST_INTERVAL(raySphere(ro, rd, vec3(-8, 1, 6), 1.0), CSG_MAT_RED);

    // Box
    TEST_INTERVAL(rayBox(ro, rd, vec3(-4, 1, 6), vec3(0.8, 0.8, 0.8)), CSG_MAT_GREEN);

    // Cylinder
    TEST_INTERVAL(rayCylinder(ro, rd, vec3(0, 0, 6), 0.7, 2.0), CSG_MAT_BLUE);

    // Cone
    TEST_INTERVAL(rayCone(ro, rd, vec3(4, 0, 6), 1.0, 2.0), CSG_MAT_GOLD);

    // Torus
    TEST_INTERVAL(rayTorus(ro, rd, vec3(8, 1, 6), 0.8, 0.3), CSG_MAT_SILVER);

    // ========================================
    // Row 2 (z = 2): CSG Subtract operations
    // ========================================

    // Sphere minus box (classic hole punch)
    {
        vec3 c = vec3(-6, 1.2, 2);
        Interval a = raySphere(ro, rd, c, 1.2);
        Interval b = rayBox(ro, rd, c, vec3(0.5, 1.5, 0.5));
        TEST_INTERVAL(opSubtract(a, b), CSG_MAT_RED);
    }

    // Box minus sphere (rounded cavity)
    {
        vec3 c = vec3(-2, 1, 2);
        Interval a = rayBox(ro, rd, c, vec3(1.0, 1.0, 1.0));
        Interval b = raySphere(ro, rd, c, 1.15);
        TEST_INTERVAL(opSubtract(a, b), CSG_MAT_GREEN);
    }

    // Cylinder minus cylinder (tube)
    {
        vec3 c = vec3(2, 0, 2);
        Interval a = rayCylinder(ro, rd, c, 1.0, 2.0);
        Interval b = rayCylinder(ro, rd, c, 0.6, 2.5);
        TEST_INTERVAL(opSubtract(a, b), CSG_MAT_BLUE);
    }

    // Sphere minus three boxes (dice-like cuts)
    {
        vec3 c = vec3(6, 1.2, 2);
        Interval s = raySphere(ro, rd, c, 1.2);
        Interval bx = rayBox(ro, rd, c, vec3(1.5, 0.4, 0.4));
        Interval by = rayBox(ro, rd, c, vec3(0.4, 1.5, 0.4));
        Interval bz = rayBox(ro, rd, c, vec3(0.4, 0.4, 1.5));
        Interval result = opSubtract(opSubtract(opSubtract(s, bx), by), bz);
        TEST_INTERVAL(result, CSG_MAT_GOLD);
    }

    // ========================================
    // Row 3 (z = -2): CSG Intersect operations
    // ========================================

    // Sphere intersect box (rounded box)
    {
        vec3 c = vec3(-6, 1, -2);
        Interval a = raySphere(ro, rd, c, 1.3);
        Interval b = rayBox(ro, rd, c, vec3(0.9, 0.9, 0.9));
        TEST_INTERVAL(opIntersect(a, b), CSG_MAT_SILVER);
    }

    // Two spheres intersect (lens shape)
    {
        Interval a = raySphere(ro, rd, vec3(-2.5, 1, -2), 1.2);
        Interval b = raySphere(ro, rd, vec3(-1.5, 1, -2), 1.2);
        TEST_INTERVAL(opIntersect(a, b), CSG_MAT_GLASS);
    }

    // Cylinder intersect sphere (capsule segment)
    {
        vec3 c = vec3(2, 1, -2);
        Interval a = rayCylinder(ro, rd, vec3(2, -0.5, -2), 0.8, 3.0);
        Interval b = raySphere(ro, rd, c, 1.3);
        TEST_INTERVAL(opIntersect(a, b), CSG_MAT_BLUE);
    }

    // Box intersect two spheres (peanut in box)
    {
        vec3 c = vec3(6, 1, -2);
        Interval box = rayBox(ro, rd, c, vec3(1.5, 0.8, 0.8));
        Interval s1 = raySphere(ro, rd, c + vec3(-0.6, 0, 0), 1.0);
        Interval s2 = raySphere(ro, rd, c + vec3(0.6, 0, 0), 1.0);
        Interval peanut = opUnion(s1, s2);
        TEST_INTERVAL(opIntersect(box, peanut), CSG_MAT_RED);
    }

    // ========================================
    // Row 4 (z = -6): CSG Union + complex combos
    // ========================================

    // Union of sphere and box (blob with cube)
    {
        Interval a = raySphere(ro, rd, vec3(-6, 1.2, -6), 0.9);
        Interval b = rayBox(ro, rd, vec3(-6, 0.5, -6), vec3(0.6, 0.5, 0.6));
        TEST_INTERVAL(opUnion(a, b), CSG_MAT_GREEN);
    }

    // Snowman (three spheres)
    {
        Interval s1 = raySphere(ro, rd, vec3(-2, 0.6, -6), 0.6);
        Interval s2 = raySphere(ro, rd, vec3(-2, 1.5, -6), 0.45);
        Interval s3 = raySphere(ro, rd, vec3(-2, 2.2, -6), 0.3);
        TEST_INTERVAL(opUnion(opUnion(s1, s2), s3), CSG_MAT_SILVER);
    }

    // Cylinder with spherical ends (capsule via CSG)
    {
        vec3 c = vec3(2, 0, -6);
        Interval cyl = rayCylinder(ro, rd, c, 0.5, 2.0);
        Interval s1 = raySphere(ro, rd, c + vec3(0, 0, 0), 0.5);
        Interval s2 = raySphere(ro, rd, c + vec3(0, 2, 0), 0.5);
        TEST_INTERVAL(opUnion(opUnion(cyl, s1), s2), CSG_MAT_GOLD);
    }

    // Complex: (sphere union cylinder) minus box
    {
        vec3 c = vec3(6, 1, -6);
        Interval sph = raySphere(ro, rd, c, 1.0);
        Interval cyl = rayCylinder(ro, rd, c - vec3(0, 1, 0), 0.4, 2.0);
        Interval combo = opUnion(sph, cyl);
        Interval box = rayBox(ro, rd, c + vec3(0.5, 0, 0), vec3(0.8, 1.5, 0.3));
        TEST_INTERVAL(opSubtract(combo, box), CSG_MAT_BLUE);
    }

    #undef TEST_INTERVAL

    return closestT < tMax;
}
#endif

// ============================================================================
// ROTATION FUNCTIONS (for instance transforms)
// ============================================================================
vec3 rotateX(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(v.x, c * v.y - s * v.z, s * v.y + c * v.z);
}

vec3 rotateY(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(c * v.x + s * v.z, v.y, -s * v.x + c * v.z);
}

vec3 rotateZ(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(c * v.x - s * v.y, s * v.x + c * v.y, v.z);
}

vec3 rotateXYZ(vec3 v, vec3 angles) {
    return rotateZ(rotateY(rotateX(v, angles.x), angles.y), angles.z);
}

vec3 rotateXYZInverse(vec3 v, vec3 angles) {
    return rotateX(rotateY(rotateZ(v, -angles.z), -angles.y), -angles.x);
}

// ============================================================================
// CAMERA
// ============================================================================
struct Ray {
    vec3 origin;
    vec3 direction;
};

Ray getCameraRay(vec2 uv, vec2 jitter) {
    vec3 forward = normalize(pc.camTarget - pc.camPos);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = cross(right, forward);

    // Apply subpixel jitter for anti-aliasing
    vec2 jitteredUV = uv + jitter / vec2(pc.width, pc.height);

    float aspect = float(pc.width) / float(pc.height);
    float fov = 0.8;
    vec3 dir = normalize(forward + (jitteredUV.x - 0.5) * fov * aspect * right + (jitteredUV.y - 0.5) * fov * up);

    return Ray(pc.camPos, dir);
}

// ============================================================================
// BVH TRAVERSAL
// ============================================================================
bool isLeaf(uint nodeIdx) {
    return (bvhNodes[nodeIdx].rightOrCount & 0x80000000u) != 0u;
}

uint patchCount(uint nodeIdx) {
    return bvhNodes[nodeIdx].rightOrCount & 0x7FFFFFFFu;
}

bool hitInstance(Ray localRay, float tMin, float tMax,
                 out float hitT, out vec3 hitN, out float hitU, out float hitV) {
    bool hit = false;
    float closestT = tMax;

    uint stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        uint nodeIdx = stack[--stackPtr];
        BVHNode node = bvhNodes[nodeIdx];

        vec3 aabbMin = vec3(node.minX, node.minY, node.minZ);
        vec3 aabbMax = vec3(node.maxX, node.maxY, node.maxZ);

        if (!hitAABB(aabbMin, aabbMax, localRay.origin, localRay.direction, tMin, closestT)) {
            continue;
        }

        if (isLeaf(nodeIdx)) {
            uint first = node.leftOrFirst;
            uint count = patchCount(nodeIdx);

            for (uint i = 0; i < count; i++) {
                uint patchIdx = patchIndices[first + i];

                vec3 cp[16];
                for (int j = 0; j < 16; j++) {
                    cp[j] = patchData[patchIdx * 16 + j].xyz;
                }

                float t, u, v;
                vec3 n;
                if (hitBezierPatch(cp, localRay.origin, localRay.direction, tMin, closestT, t, u, v, n)) {
                    hit = true;
                    closestT = t;
                    hitT = t;
                    hitN = n;
                    hitU = u;
                    hitV = v;
                }
            }
        } else {
            stack[stackPtr++] = node.rightOrCount;
            stack[stackPtr++] = node.leftOrFirst;
        }
    }

    return hit;
}

bool hitAllInstances(Ray worldRay, float tMin, float tMax,
                     out float hitT, out vec3 hitN, out uint hitInstanceId) {
    bool hit = false;
    float closestT = tMax;

    for (uint i = 0; i < pc.numInstances; i++) {
        BezierInstance inst = instances[i];

        Ray localRay;
        vec3 translated = worldRay.origin - inst.position;
        localRay.origin = rotateXYZInverse(translated, inst.rotation) / inst.scale;
        localRay.direction = rotateXYZInverse(worldRay.direction, inst.rotation);

        float localTMax = closestT / inst.scale;

        float t, u, v;
        vec3 n;
        if (hitInstance(localRay, tMin / inst.scale, localTMax, t, n, u, v)) {
            float worldT = t * inst.scale;
            if (worldT < closestT) {
                hit = true;
                closestT = worldT;
                hitT = worldT;
                hitN = rotateXYZ(n, inst.rotation);
                hitInstanceId = i;
            }
        }
    }

    return hit;
}

// ============================================================================
// MATERIAL TYPES
// ============================================================================
#define MAT_DIFFUSE  0
#define MAT_METAL    1
#define MAT_GLASS    2
#define MAT_EMISSIVE 3

// ============================================================================
// MAIN RENDER LOOP
// ============================================================================
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pc.width) || pixel.y >= int(pc.height)) return;

    // Initialize RNG - use frame index for temporal variation when accumulating
#if FEATURE_ACCUMULATION
    initRNGTemporal(pixel, pc.frameIndex);
    // Adaptive iterations: more for first frames, fewer once accumulating
    g_newtonMaxIter = (pc.frameIndex < 4) ? NEWTON_MAX_ITER : 4;
#else
    initRNG(pixel);
#endif

    vec2 uv = vec2(pixel) / vec2(pc.width, pc.height);
    uv.y = 1.0 - uv.y;

    // Subpixel jitter for anti-aliasing
#if FEATURE_JITTER
    vec2 jitter = vec2(rand() - 0.5, rand() - 0.5);
#else
    vec2 jitter = vec2(0.0);
#endif

    Ray ray = getCameraRay(uv, jitter);
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0);

    // Material properties per instance - 6 teapots showcasing different effects
    uint materialTypes[6] = uint[](MAT_DIFFUSE, MAT_METAL, MAT_METAL, MAT_METAL, MAT_GLASS, MAT_GLASS);
    vec3 baseColors[6] = vec3[](
        vec3(0.85, 0.55, 0.35),  // 0: Terracotta ceramic
        vec3(0.95, 0.95, 0.97),  // 1: Polished silver
        vec3(0.83, 0.69, 0.22),  // 2: Brushed gold
        vec3(0.85, 0.55, 0.40),  // 3: Hammered copper
        vec3(1.0, 1.0, 1.0),     // 4: Clear glass
        vec3(0.4, 0.9, 0.5)      // 5: Green glass (for absorption tint)
    );
    float roughnessVals[6] = float[](0.0, 0.0, 0.25, 0.02, 0.0, 0.0);
    float bumpScale[6] = float[](0.0, 0.0, 0.0, 25.0, 0.0, 0.0);
    float bumpStrength[6] = float[](0.0, 0.0, 0.0, 0.4, 0.0, 0.0);

    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
        float t;
        vec3 normal;
        uint instanceId;
        bool hitFloorFlag = false;
#if FEATURE_CSG
        bool hitCSGFlag = false;
        int csgMatId = 0;
#endif

        bool hitBezier = hitAllInstances(ray, EPSILON, T_MAX, t, normal, instanceId);

#if FEATURE_CSG
        // CSG object test (interval-based, exact edges)
        float csgT;
        vec3 csgN;
        int csgMat;
        float tMaxCSG = hitBezier ? t : T_MAX;
        if (hitCSG(ray.origin, ray.direction, EPSILON, tMaxCSG, csgT, csgN, csgMat)) {
            t = csgT;
            normal = csgN;
            hitCSGFlag = true;
            csgMatId = csgMat;
            hitBezier = false;
        }
#endif

#if FEATURE_FLOOR
        float floorT;
        vec3 floorN;
#if FEATURE_CSG
        float tMaxFloor = (hitBezier || hitCSGFlag) ? t : T_MAX;
#else
        float tMaxFloor = hitBezier ? t : T_MAX;
#endif
        if (hitFloorPlane(ray.origin, ray.direction, -1.0, EPSILON, tMaxFloor, floorT, floorN)) {
            t = floorT;
            normal = floorN;
            hitFloorFlag = true;
            hitBezier = false;
#if FEATURE_CSG
            hitCSGFlag = false;
#endif
        }
#endif

#if FEATURE_CSG
        if (!hitBezier && !hitFloorFlag && !hitCSGFlag) {
#else
        if (!hitBezier && !hitFloorFlag) {
#endif
            color += throughput * skyGradient(ray.direction);
            break;
        }

        vec3 hitPoint = ray.origin + t * ray.direction;

        // Floor material
#if FEATURE_FLOOR
        if (hitFloorFlag) {
            vec3 floorColor = checkerPattern(hitPoint, 2.0, vec3(0.9), vec3(0.1));
            vec3 lightDir = normalize(vec3(1, 2, 1));
            float NdotL = max(dot(normal, lightDir), 0.0);

            float shadow = 1.0;
#if FEATURE_SHADOWS
            float shadowT;
            vec3 shadowN;
            uint shadowId;
            vec3 shadowOrigin = hitPoint + normal * EPSILON * 2.0;
            if (hitAllInstances(Ray(shadowOrigin, lightDir),
                                EPSILON, T_MAX, shadowT, shadowN, shadowId)) {
                shadow = 0.3;
            }
#if FEATURE_CSG
            int shadowMat;
            float csgShadowT;
            vec3 csgShadowN;
            if (hitCSG(shadowOrigin, lightDir, EPSILON, T_MAX, csgShadowT, csgShadowN, shadowMat)) {
                shadow = 0.3;
            }
#endif
#endif
            color += throughput * floorColor * (0.2 + 0.8 * NdotL * shadow);
            break;
        }
#endif

#if FEATURE_CSG
        // CSG object materials
        if (hitCSGFlag) {
            // Material colors for CSG objects
            vec3 csgColors[6] = vec3[](
                vec3(0.9, 0.2, 0.2),   // 0: Red metal
                vec3(0.2, 0.8, 0.3),   // 1: Green metal
                vec3(0.2, 0.4, 0.9),   // 2: Blue metal
                vec3(0.83, 0.69, 0.22),// 3: Gold metal
                vec3(0.95, 0.95, 0.97),// 4: Silver metal
                vec3(0.9, 0.95, 1.0)   // 5: Glass (slightly blue tint)
            );

            vec3 csgColor = csgColors[csgMatId];

            // Glass material for CSG_MAT_GLASS
            if (csgMatId == CSG_MAT_GLASS) {
                float ior = 1.5;
                float cosTheta = dot(-ray.direction, normal);
                bool entering = cosTheta > 0.0;
                vec3 n = entering ? normal : -normal;
                float eta = entering ? (1.0 / ior) : ior;

                vec3 refracted = refract(ray.direction, n, eta);
                if (length(refracted) < 0.5) {
                    ray.origin = hitPoint + n * EPSILON * 2.0;
                    ray.direction = reflect(ray.direction, n);
                } else {
                    ray.origin = hitPoint - n * EPSILON * 2.0;
                    ray.direction = refracted;
                }
                throughput *= csgColor;
            } else {
                // Metal reflection
                ray.origin = hitPoint + normal * EPSILON * 2.0;
                ray.direction = reflect(ray.direction, normal);
                throughput *= csgColor;
            }
            continue;  // Bounce
        }
#endif

        uint matType = materialTypes[instanceId % 6];
        vec3 baseColor = baseColors[instanceId % 6];

#if FEATURE_BUMP
        float bs = bumpScale[instanceId % 6];
        float bstr = bumpStrength[instanceId % 6];
        if (bstr > 0.0) {
            normal = bumpNormal(hitPoint, normal, bs, bstr);
        }
#endif

        // ----- DIFFUSE -----
        if (matType == MAT_DIFFUSE) {
            vec3 lightDir = normalize(vec3(1, 2, 1));
            float NdotL = max(dot(normal, lightDir), 0.0);

            float shadow = 1.0;
#if FEATURE_SHADOWS
            float shadowT;
            vec3 shadowN;
            uint shadowId;
            vec3 shadowOrigin = hitPoint + normal * EPSILON * 2.0;
            if (hitAllInstances(Ray(shadowOrigin, lightDir),
                                EPSILON, T_MAX, shadowT, shadowN, shadowId)) {
                shadow = 0.3;
            }
#if FEATURE_CSG
            int shadowMat;
            float csgShadowT;
            vec3 csgShadowN;
            if (hitCSG(shadowOrigin, lightDir, EPSILON, T_MAX, csgShadowT, csgShadowN, shadowMat)) {
                shadow = 0.3;
            }
#endif
#endif
            color += throughput * baseColor * (0.15 + 0.85 * NdotL * shadow);
            break;
        }

        // ----- METAL -----
#if FEATURE_REFLECTION
        else if (matType == MAT_METAL) {
            ray.origin = hitPoint + normal * EPSILON * 2.0;

#if FEATURE_ROUGHNESS
            float r = roughnessVals[instanceId % 6];
            if (r > 0.001) {
                vec3 H = sampleGGX(normal, r);
                ray.direction = reflect(ray.direction, H);
                if (dot(ray.direction, normal) < 0.0) {
                    ray.direction = reflect(ray.direction, normal);
                }
            } else {
                ray.direction = reflect(ray.direction, normal);
            }
#else
            ray.direction = reflect(ray.direction, normal);
#endif
            throughput *= baseColor;
        }
#endif

        // ----- GLASS -----
#if FEATURE_REFRACTION
        else if (matType == MAT_GLASS) {
            float ior = 1.5;
            float cosTheta = dot(-ray.direction, normal);
            bool entering = cosTheta > 0.0;

            vec3 n = entering ? normal : -normal;
            float eta = entering ? (1.0 / ior) : ior;
            cosTheta = abs(cosTheta);

#if FEATURE_ABSORPTION
            if (!entering) {
                vec3 absorptionCoeff = vec3(0.2, 0.5, 0.8);
                throughput *= exp(-absorptionCoeff * t);
            }
#endif

#if FEATURE_FRESNEL
            float F = fresnel(cosTheta, ior);
            bool doReflect = (F > 0.5);
#else
            bool doReflect = false;
#endif

            if (doReflect) {
                ray.origin = hitPoint + n * EPSILON * 2.0;
                ray.direction = reflect(ray.direction, n);
            } else {
                vec3 refracted = refract(ray.direction, n, eta);
                if (length(refracted) < 0.5) {
                    ray.origin = hitPoint + n * EPSILON * 2.0;
                    ray.direction = reflect(ray.direction, n);
                } else {
                    ray.origin = hitPoint - n * EPSILON * 2.0;
                    ray.direction = refracted;
                }
            }
            throughput *= baseColor;
        }
#endif

        // ----- EMISSIVE -----
#if FEATURE_EMISSION
        else if (matType == MAT_EMISSIVE) {
            color += throughput * baseColor * 5.0;
            break;
        }
#endif
    }

    // Accumulation blending (in linear space, before gamma)
#if FEATURE_ACCUMULATION
    if (pc.frameIndex > 0) {
        vec3 accumColor = imageLoad(accumImage, pixel).rgb;
        float weight = 1.0 / float(pc.frameIndex + 1);
        color = mix(accumColor, color, weight);
    }
    imageStore(accumImage, pixel, vec4(color, 1.0));
#endif

    // Gamma correction for display
    vec3 displayColor = pow(clamp(color, 0.0, 1.0), vec3(1.0 / 2.2));
    imageStore(outputImage, pixel, vec4(displayColor, 1.0));
}
