#version 460

layout(local_size_x = 16, local_size_y = 16) in;

// Output and accumulation images
layout(rgba8, set = 0, binding = 0) uniform writeonly image2D outputImage;
layout(rgba32f, set = 0, binding = 1) uniform image2D accumImage;

// ============ GPU STRUCTS ============
// Must match C++ struct layout exactly

struct Sphere {
    vec3 center;
    float _center_pad;
    float radius;
    uint materialId;
    float _pad[2];
};

struct Box {
    vec3 center;
    float _center_pad;
    vec3 halfExtents;
    float _halfExt_pad;
    uint materialId;
    float _pad[3];
};

struct Cylinder {
    vec3 base;
    float _base_pad;
    vec3 axis;
    float _axis_pad;
    float radius;
    float height;
    uint materialId;
    uint caps;
};

struct Cone {
    vec3 base;
    float _base_pad;
    vec3 axis;
    float _axis_pad;
    float radius;
    float height;
    uint materialId;
    uint cap;
};

struct Torus {
    vec3 center;
    float _center_pad;
    vec3 axis;
    float _axis_pad;
    float majorRadius;
    float minorRadius;
    uint materialId;
    uint _pad;
};

struct SpotLight {
    vec3 position;
    float _pos_pad;
    vec3 direction;
    float _dir_pad;
    vec3 color;
    float _col_pad;
    float innerAngle;
    float outerAngle;
    uint goboType;
    float goboScale;
    float goboRotation;
    float _pad[3];
};

struct Material {
    vec3 albedo;
    float _pad1;
    vec3 emission;
    float _pad2;
    uint type;
    float param;
    float param2;
    float _pad3;
};

// ============ BUFFERS ============

layout(std430, set = 0, binding = 2) readonly buffer SphereBuffer {
    Sphere spheres[];
};

layout(std430, set = 0, binding = 3) readonly buffer MaterialBuffer {
    Material materials[];
};

layout(std430, set = 0, binding = 5) readonly buffer BoxBuffer {
    Box boxes[];
};

layout(std430, set = 0, binding = 6) readonly buffer SpotLightBuffer {
    SpotLight spotLights[];
};

layout(std430, set = 0, binding = 7) readonly buffer CylinderBuffer {
    Cylinder cylinders[];
};

layout(std430, set = 0, binding = 8) readonly buffer ConeBuffer {
    Cone cones[];
};

layout(std430, set = 0, binding = 9) readonly buffer TorusBuffer {
    Torus tori[];
};

// Bezier patch structures
struct BVHNode {
    float minX, minY, minZ;
    uint leftOrFirst;
    float maxX, maxY, maxZ;
    uint rightOrCount;
};

struct BezierInstance {
    vec3 position;
    float scale;
    vec3 rotation;  // Euler XYZ
    uint materialId;
};

layout(std430, set = 0, binding = 10) readonly buffer BezierPatchBuffer {
    vec4 bezierPatches[];  // 16 vec4s per patch
};

layout(std430, set = 0, binding = 11) readonly buffer BezierBVHBuffer {
    BVHNode bezierBVHNodes[];
};

layout(std430, set = 0, binding = 12) readonly buffer BezierIndexBuffer {
    uint bezierPatchIndices[];
};

layout(std430, set = 0, binding = 13) readonly buffer BezierInstanceBuffer {
    BezierInstance bezierInstances[];
};

layout(std140, set = 0, binding = 4) uniform CameraUBO {
    vec3 origin;
    float _pad1;
    vec3 lowerLeftCorner;
    float _pad2;
    vec3 horizontal;
    float _pad3;
    vec3 vertical;
    float _pad4;
    vec3 u;
    float _pad5;
    vec3 v;
    float _pad6;
    vec3 w;
    float _pad7;
    float lensRadius;
    float _padEnd[3];
} camera;

layout(push_constant) uniform PushConstants {
    uint frameIndex;
    uint sampleCount;
    uint maxBounces;
    uint sphereCount;
    uint boxCount;
    uint cylinderCount;
    uint coneCount;
    uint torusCount;
    uint spotLightCount;
    uint width;
    uint height;
    uint useNEE;
    uint accumulate;
    float sunElevation;
    float sunAzimuth;
    uint bezierPatchCount;
    uint bezierBVHNodeCount;
    uint bezierInstanceCount;
    uint _pad;
} pc;

// ============ CONSTANTS ============

const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float T_MAX = 10000.0;

// ============ INCLUDES ============

#include "noise.glsl"
#include "random.glsl"
#include "includes/bezier.glsl"
#include "geometry.glsl"
#include "materials.glsl"
#include "lights.glsl"

// ============ PATH TRACING ============

vec3 tracePath(Ray ray) {
    vec3 radiance = vec3(0.0);
    vec3 throughput = vec3(1.0);
    bool lastBounceSpecular = true;

    vec3 lightPos, lightEmission;
    float lightRadius;
    uint lightCount;

    for (uint bounce = 0; bounce < pc.maxBounces; bounce++) {
        HitRecord rec;

        if (!hitScene(ray, EPSILON, T_MAX, rec)) {
            vec3 unitDir = normalize(ray.direction);

            // Sun direction from elevation and azimuth
            float cosElev = cos(pc.sunElevation);
            float sinElev = sin(pc.sunElevation);
            vec3 sunDir = vec3(cosElev * sin(pc.sunAzimuth), sinElev, cosElev * cos(pc.sunAzimuth));
            float sunAngularRadius = 0.02;
            vec3 sunColor = vec3(50.0, 47.0, 40.0);

            vec3 envLight;
            vec3 betaR = vec3(0.18, 0.41, 1.0);  // Rayleigh scattering

            float sunAlt = sunDir.y;
            float daylight = smoothstep(-0.31, 0.0, sunAlt);
            float twilight = smoothstep(-0.31, -0.1, sunAlt) * smoothstep(0.1, -0.05, sunAlt);

            if (unitDir.y > 0.0) {
                // Sky above horizon
                float sunOpticalDepth;
                if (sunAlt > 0.0) {
                    sunOpticalDepth = 1.0 / (sunAlt + 0.15);
                } else {
                    sunOpticalDepth = 8.0 + abs(sunAlt) * 20.0;
                }
                sunOpticalDepth = min(sunOpticalDepth, 15.0);

                vec3 sunTransmit = exp(-betaR * sunOpticalDepth * 0.5);
                vec3 incomingSunLight = sunTransmit * daylight * 1.5;

                float viewAltitude = max(unitDir.y, 0.001);
                float viewOpticalDepth = exp(-viewAltitude * 4.0) / viewAltitude;
                viewOpticalDepth = min(viewOpticalDepth, 40.0);

                float cosAngle = dot(unitDir, sunDir);
                float phase = 0.75 * (1.0 + cosAngle * cosAngle);

                vec3 scatter = (vec3(1.0) - exp(-betaR * viewOpticalDepth * 0.4)) * phase;
                vec3 skyColor = scatter * incomingSunLight;

                float sunProximity = max(0.0, cosAngle);
                float miePhase = pow(sunProximity, 4.0);
                float mieGlow = pow(sunProximity, 32.0);
                vec3 mieColor = incomingSunLight * (miePhase * 0.3 + mieGlow * 2.0);

                float horizonGlow = exp(-viewAltitude * 8.0);
                vec3 twilightColor = vec3(0.8, 0.3, 0.1) * twilight * horizonGlow * 0.5;

                vec3 nightSky = vec3(0.001, 0.002, 0.008) * (1.0 + viewAltitude * 0.5);

                // Stars
                float starVisibility = (1.0 - daylight) * (1.0 - twilight * 2.0);
                if (starVisibility > 0.3) {
                    vec3 starPos = floor(unitDir * 500.0);
                    float starHash = fract(sin(dot(starPos, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
                    if (starHash > 0.997) {
                        float starBright = pow(starHash - 0.997, 0.5) * 30.0;
                        float twinkle = 0.7 + 0.3 * sin(float(pc.frameIndex) * 0.1 + starHash * 100.0);
                        nightSky += vec3(starBright * twinkle * starVisibility);
                    }
                }

                envLight = skyColor + mieColor + twilightColor + nightSky * (1.0 - daylight);

                // Sun disc
                float sunThreshold = cos(sunAngularRadius);
                if (sunAlt > -0.02 && cosAngle > sunThreshold) {
                    vec3 discColor = sunTransmit * sunColor;
                    float sampleFactor = clamp(float(pc.frameIndex) / 200.0, 0.0, 1.0);
                    float maxSun = mix(1.5, 50.0, sampleFactor * sampleFactor);
                    envLight = min(discColor * daylight, vec3(maxSun));
                }
            } else {
                // Below horizon (ocean)
                float depth = -unitDir.y;
                float sunOpticalDepth;
                if (sunAlt > 0.0) {
                    sunOpticalDepth = 1.0 / (sunAlt + 0.15);
                } else {
                    sunOpticalDepth = 8.0 + abs(sunAlt) * 20.0;
                }
                vec3 sunTransmit = exp(-betaR * min(sunOpticalDepth, 15.0) * 0.5);

                vec3 horizonOcean = vec3(0.08, 0.15, 0.25) * sunTransmit * daylight;
                vec3 twilightOcean = vec3(0.03, 0.02, 0.04) * twilight;
                vec3 nightOcean = vec3(0.001, 0.002, 0.005);
                vec3 deepOcean = vec3(0.005, 0.01, 0.02) * daylight + nightOcean;

                envLight = mix(horizonOcean + twilightOcean + nightOcean, deepOcean, depth);
            }

            radiance += throughput * envLight;
            break;
        }

        Material mat = materials[rec.materialId];

        // Emission (for emissive surfaces)
        if (mat.type == 3 && (lastBounceSpecular || pc.useNEE == 0)) {
            radiance += min(throughput * mat.emission, vec3(50.0));
        }

        // NEE: Sample sun for diffuse surfaces
        if (pc.useNEE == 1 && mat.type == 0) {
            float cosElev = cos(pc.sunElevation);
            float sinElev = sin(pc.sunElevation);
            vec3 sunDir = vec3(cosElev * sin(pc.sunAzimuth), sinElev, cosElev * cos(pc.sunAzimuth));

            if (sunDir.y > 0.0) {
                float sunAngularRadius = 0.02;
                vec3 sunColor = vec3(50.0, 47.0, 40.0);

                vec3 betaR = vec3(0.18, 0.41, 1.0);
                float sunOpticalDepth = min(1.0 / (sunDir.y + 0.15), 8.0);
                vec3 sunTransmit = exp(-betaR * sunOpticalDepth * 0.5);

                vec3 u, v;
                if (abs(sunDir.y) < 0.99) {
                    u = normalize(cross(sunDir, vec3(0, 1, 0)));
                } else {
                    u = normalize(cross(sunDir, vec3(1, 0, 0)));
                }
                v = cross(sunDir, u);

                float r1 = rand();
                float r2 = rand();
                float theta = sunAngularRadius * sqrt(r1);
                float phi = 2.0 * PI * r2;
                vec3 lightDir = normalize(sunDir + theta * (cos(phi) * u + sin(phi) * v));

                float NdotL = dot(rec.normal, lightDir);
                vec3 shadowOrigin = rec.point + rec.normal * 0.001;

                if (NdotL > 0.0 && !shadowRay(shadowOrigin, lightDir, T_MAX)) {
                    float solidAngle = PI * sunAngularRadius * sunAngularRadius;
                    vec3 brdf = mat.albedo / PI;
                    vec3 attenuatedSunColor = sunColor * sunTransmit;
                    vec3 directLight = throughput * brdf * attenuatedSunColor * NdotL * solidAngle;

                    float neeFactor = clamp(float(pc.frameIndex) / 200.0, 0.0, 1.0);
                    float neeClamp = mix(2.0, 50.0, neeFactor * neeFactor);
                    radiance += min(directLight, vec3(neeClamp));
                }
            }
        }

        // NEE: Sample spotlights for diffuse surfaces
        if (pc.useNEE == 1 && mat.type == 0 && pc.spotLightCount > 0u) {
            for (uint i = 0u; i < pc.spotLightCount; i++) {
                SpotLight light = spotLights[i];
                vec3 lightDir;
                float lightDist;
                vec3 lightContrib = evaluateSpotLight(light, rec.point, rec.normal, lightDir, lightDist);

                if (length(lightContrib) > 0.0) {
                    float NdotL = dot(rec.normal, lightDir);
                    if (NdotL > 0.0) {
                        vec3 shadowOrigin = rec.point + rec.normal * 0.001;
                        if (!shadowRay(shadowOrigin, lightDir, lightDist)) {
                            vec3 brdf = mat.albedo / PI;
                            vec3 directLight = throughput * brdf * lightContrib * NdotL;

                            float neeFactor = clamp(float(pc.frameIndex) / 200.0, 0.0, 1.0);
                            float neeClamp = mix(2.0, 50.0, neeFactor * neeFactor);
                            radiance += min(directLight, vec3(neeClamp));
                        }
                    }
                }
            }
        }

        // Scatter
        vec3 attenuation;
        Ray scattered;
        if (!scatter(ray, rec, attenuation, scattered)) {
            break;
        }

        throughput *= attenuation;
        ray = scattered;
        lastBounceSpecular = (mat.type == 1 || mat.type == 2 || mat.type == 4 || mat.type == 6);

        // Russian roulette termination
        if (bounce > 3) {
            float p = max(throughput.r, max(throughput.g, throughput.b));
            if (rand() > p) break;
            throughput /= p;
        }
    }

    return radiance;
}

// ============ CAMERA & MAIN ============

Ray getCameraRay(vec2 uv) {
    vec3 direction = camera.lowerLeftCorner
                   + uv.x * camera.horizontal
                   + uv.y * camera.vertical
                   - camera.origin;
    return Ray(camera.origin, normalize(direction));
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    if (pixel.x >= int(pc.width) || pixel.y >= int(pc.height))
        return;

    initRNG(uvec2(pixel), pc.frameIndex);

    uint samples = pc.sampleCount;

    vec3 color = vec3(0.0);
    for (uint s = 0; s < samples; s++) {
        vec2 uv = (vec2(pixel) + rand2()) / vec2(pc.width, pc.height);
        uv.y = 1.0 - uv.y;

        Ray ray = getCameraRay(uv);
        vec3 sampleColor = tracePath(ray);

        if (any(isnan(sampleColor)) || any(isinf(sampleColor))) {
            sampleColor = vec3(0.0);
        }
        sampleColor = clamp(sampleColor, vec3(0.0), vec3(20.0));

        color += sampleColor;
    }
    color /= float(samples);

    // Hybrid accumulation
    vec4 prev = imageLoad(accumImage, pixel);
    vec3 blended;

    if (pc.accumulate == 0) {
        blended = mix(prev.rgb, color, 0.5);
    } else {
        uint cappedFrame = min(pc.frameIndex, 32u);
        float weight = 1.0 / float(cappedFrame + 1);
        blended = mix(prev.rgb, color, weight);
    }
    imageStore(accumImage, pixel, vec4(blended, 1.0));

    // Bilateral filter during movement
    vec3 filtered = blended;
    if (pc.accumulate == 0) {
        const float sigmaSpatial = 1.0;
        const float sigmaColor = 0.1;

        vec3 sum = vec3(0.0);
        float weightSum = 0.0;

        for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
                ivec2 samplePos = pixel + ivec2(dx, dy);

                if (samplePos.x >= 0 && samplePos.x < int(pc.width) &&
                    samplePos.y >= 0 && samplePos.y < int(pc.height)) {

                    vec3 sampleColor = imageLoad(accumImage, samplePos).rgb;

                    float spatialDist = float(dx * dx + dy * dy);
                    float spatialWeight = exp(-spatialDist / (2.0 * sigmaSpatial * sigmaSpatial));

                    vec3 colorDiff = sampleColor - blended;
                    float colorDist = dot(colorDiff, colorDiff);
                    float colorWeight = exp(-colorDist / (2.0 * sigmaColor * sigmaColor));

                    float weight = spatialWeight * colorWeight;
                    sum += sampleColor * weight;
                    weightSum += weight;
                }
            }
        }

        filtered = sum / max(weightSum, 0.0001);
    }

    vec3 finalColor = clamp(filtered, vec3(0.0), vec3(1.0));
    finalColor = pow(finalColor, vec3(1.0 / 2.2));

    imageStore(outputImage, pixel, vec4(finalColor, 1.0));
}
