#version 460

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba8, set = 0, binding = 0) uniform writeonly image2D outputImage;

// Push constants
layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
    uint numPatches;
    uint numBVHNodes;
    vec3 camPos;
    uint frameIndex;
    vec3 camTarget;
    float _pad2;
} pc;

// Patch control points: 16 vec4s per patch (w unused, for alignment)
layout(std430, set = 0, binding = 1) readonly buffer PatchBuffer {
    vec4 patchData[];  // patchData[patchIndex * 16 + pointIndex]
};

// BVH nodes (64 bytes each, matching CPU struct)
struct BVHNode {
    float minX, minY, minZ;
    uint leftOrFirst;   // Left child index, or first patch index if leaf
    float maxX, maxY, maxZ;
    uint rightOrCount;  // Right child index, or patch count if leaf (high bit = leaf flag)
};

layout(std430, set = 0, binding = 2) readonly buffer BVHBuffer {
    BVHNode bvhNodes[];
};

// Patch indices (reordered by BVH build)
layout(std430, set = 0, binding = 3) readonly buffer PatchIndexBuffer {
    uint patchIndices[];
};

const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float T_MAX = 1000.0;

#include "includes/bezier.glsl"

// Simple camera
struct Ray {
    vec3 origin;
    vec3 direction;
};

Ray getCameraRay(vec2 uv) {
    // Simple perspective camera with aspect ratio
    vec3 forward = normalize(pc.camTarget - pc.camPos);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = cross(right, forward);

    float aspect = float(pc.width) / float(pc.height);
    float fov = 0.8;  // ~45 degrees
    vec3 dir = normalize(forward + (uv.x - 0.5) * fov * aspect * right + (uv.y - 0.5) * fov * up);

    return Ray(pc.camPos, dir);
}

// BVH node helpers
bool isLeaf(uint nodeIdx) {
    return (bvhNodes[nodeIdx].rightOrCount & 0x80000000u) != 0u;
}

uint patchCount(uint nodeIdx) {
    return bvhNodes[nodeIdx].rightOrCount & 0x7FFFFFFFu;
}

// Check all patches for intersection using BVH acceleration
// Returns: 0 = miss, 1 = hit, 2 = hit AABB but missed surface (debug)
int hitTeapotDebug(Ray r, float tMin, float tMax,
               out float hitT, out vec3 hitN, out float hitU, out float hitV, out uint hitPatch) {
    bool hit = false;
    bool hitAnyAABB = false;
    float closestT = tMax;

    // Stack-based BVH traversal
    uint stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;  // Start at root

    while (stackPtr > 0) {
        uint nodeIdx = stack[--stackPtr];
        BVHNode node = bvhNodes[nodeIdx];

        // Test ray against node AABB
        vec3 aabbMin = vec3(node.minX, node.minY, node.minZ);
        vec3 aabbMax = vec3(node.maxX, node.maxY, node.maxZ);

        if (!hitAABB(aabbMin, aabbMax, r.origin, r.direction, tMin, closestT)) {
            continue;
        }

        if (isLeaf(nodeIdx)) {
            hitAnyAABB = true;  // We reached a leaf AABB

            // Test all patches in this leaf
            uint first = node.leftOrFirst;
            uint count = patchCount(nodeIdx);

            for (uint i = 0; i < count; i++) {
                uint patchIdx = patchIndices[first + i];

                // Load control points for this patch
                vec3 cp[16];
                for (int j = 0; j < 16; j++) {
                    cp[j] = patchData[patchIdx * 16 + j].xyz;
                }

                float t, u, v;
                vec3 n;
                if (hitBezierPatch(cp, r.origin, r.direction, tMin, closestT, t, u, v, n)) {
                    hit = true;
                    closestT = t;
                    hitT = t;
                    hitN = n;
                    hitU = u;
                    hitV = v;
                    hitPatch = patchIdx;
                }
            }
        } else {
            // Push children onto stack (push right first so left is processed first)
            stack[stackPtr++] = node.rightOrCount;
            stack[stackPtr++] = node.leftOrFirst;
        }
    }

    if (hit) return 1;
    if (hitAnyAABB) return 2;  // Hit AABB but missed surface - Newton failed!
    return 0;
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pc.width) || pixel.y >= int(pc.height)) return;

    vec2 uv = vec2(pixel) / vec2(pc.width, pc.height);
    uv.y = 1.0 - uv.y;  // Flip Y

    Ray ray = getCameraRay(uv);

    vec3 color = vec3(0.1, 0.1, 0.15);  // Background

    float t, u, v;
    vec3 normal;
    uint patchId;

    int result = hitTeapotDebug(ray, EPSILON, T_MAX, t, normal, u, v, patchId);

    if (result == 1) {
        // Normal shading
        vec3 lightDir = normalize(vec3(1, 2, 1));
        float NdotL = max(dot(normal, lightDir), 0.0);

        vec3 baseColor = vec3(0.8, 0.6, 0.4);  // Ceramic

        color = baseColor * (0.2 + 0.8 * NdotL);

        vec3 viewDir = -ray.direction;
        vec3 halfVec = normalize(lightDir + viewDir);
        float spec = pow(max(dot(normal, halfVec), 0.0), 64.0);
        color += vec3(0.5) * spec;
    }

    // Gamma correction
    color = pow(clamp(color, 0.0, 1.0), vec3(1.0 / 2.2));

    imageStore(outputImage, pixel, vec4(color, 1.0));
}
