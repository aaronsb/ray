#version 460

layout(local_size_x = 16, local_size_y = 16) in;

layout(rgba8, set = 0, binding = 0) uniform writeonly image2D outputImage;

// Push constants
layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
    uint numPatches;
    uint numBVHNodes;
    vec3 camPos;
    uint frameIndex;
    vec3 camTarget;
    uint numInstances;
} pc;

// Patch control points: 16 vec4s per patch (w unused, for alignment)
layout(std430, set = 0, binding = 1) readonly buffer PatchBuffer {
    vec4 patchData[];  // patchData[patchIndex * 16 + pointIndex]
};

// BVH nodes (64 bytes each, matching CPU struct)
struct BVHNode {
    float minX, minY, minZ;
    uint leftOrFirst;   // Left child index, or first patch index if leaf
    float maxX, maxY, maxZ;
    uint rightOrCount;  // Right child index, or patch count if leaf (high bit = leaf flag)
};

layout(std430, set = 0, binding = 2) readonly buffer BVHBuffer {
    BVHNode bvhNodes[];
};

// Patch indices (reordered by BVH build)
layout(std430, set = 0, binding = 3) readonly buffer PatchIndexBuffer {
    uint patchIndices[];
};

// Instance data (must match CPU struct)
struct BezierInstance {
    vec3 position;
    float scale;
    vec3 rotation;  // Euler angles (radians), applied in XYZ order
    uint materialId;
};

layout(std430, set = 0, binding = 4) readonly buffer InstanceBuffer {
    BezierInstance instances[];
};

// Rotation functions
vec3 rotateX(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(v.x, c * v.y - s * v.z, s * v.y + c * v.z);
}

vec3 rotateY(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(c * v.x + s * v.z, v.y, -s * v.x + c * v.z);
}

vec3 rotateZ(vec3 v, float angle) {
    float c = cos(angle);
    float s = sin(angle);
    return vec3(c * v.x - s * v.y, s * v.x + c * v.y, v.z);
}

// Apply XYZ Euler rotation
vec3 rotateXYZ(vec3 v, vec3 angles) {
    return rotateZ(rotateY(rotateX(v, angles.x), angles.y), angles.z);
}

// Apply inverse (ZYX) rotation
vec3 rotateXYZInverse(vec3 v, vec3 angles) {
    return rotateX(rotateY(rotateZ(v, -angles.z), -angles.y), -angles.x);
}

const float PI = 3.14159265359;
const float EPSILON = 0.0001;
const float T_MAX = 1000.0;

#include "includes/bezier.glsl"

// Simple camera
struct Ray {
    vec3 origin;
    vec3 direction;
};

Ray getCameraRay(vec2 uv) {
    vec3 forward = normalize(pc.camTarget - pc.camPos);
    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));
    vec3 up = cross(right, forward);

    float aspect = float(pc.width) / float(pc.height);
    float fov = 0.8;
    vec3 dir = normalize(forward + (uv.x - 0.5) * fov * aspect * right + (uv.y - 0.5) * fov * up);

    return Ray(pc.camPos, dir);
}

// BVH node helpers
bool isLeaf(uint nodeIdx) {
    return (bvhNodes[nodeIdx].rightOrCount & 0x80000000u) != 0u;
}

uint patchCount(uint nodeIdx) {
    return bvhNodes[nodeIdx].rightOrCount & 0x7FFFFFFFu;
}

// Hit test single instance (BVH traversal in local space)
bool hitInstance(Ray localRay, float tMin, float tMax,
                 out float hitT, out vec3 hitN, out float hitU, out float hitV) {
    bool hit = false;
    float closestT = tMax;

    uint stack[32];
    int stackPtr = 0;
    stack[stackPtr++] = 0;

    while (stackPtr > 0) {
        uint nodeIdx = stack[--stackPtr];
        BVHNode node = bvhNodes[nodeIdx];

        vec3 aabbMin = vec3(node.minX, node.minY, node.minZ);
        vec3 aabbMax = vec3(node.maxX, node.maxY, node.maxZ);

        if (!hitAABB(aabbMin, aabbMax, localRay.origin, localRay.direction, tMin, closestT)) {
            continue;
        }

        if (isLeaf(nodeIdx)) {
            uint first = node.leftOrFirst;
            uint count = patchCount(nodeIdx);

            for (uint i = 0; i < count; i++) {
                uint patchIdx = patchIndices[first + i];

                vec3 cp[16];
                for (int j = 0; j < 16; j++) {
                    cp[j] = patchData[patchIdx * 16 + j].xyz;
                }

                float t, u, v;
                vec3 n;
                if (hitBezierPatch(cp, localRay.origin, localRay.direction, tMin, closestT, t, u, v, n)) {
                    hit = true;
                    closestT = t;
                    hitT = t;
                    hitN = n;
                    hitU = u;
                    hitV = v;
                }
            }
        } else {
            stack[stackPtr++] = node.rightOrCount;
            stack[stackPtr++] = node.leftOrFirst;
        }
    }

    return hit;
}

// Hit test all instances
bool hitAllInstances(Ray worldRay, float tMin, float tMax,
                     out float hitT, out vec3 hitN, out uint hitInstanceId) {
    bool hit = false;
    float closestT = tMax;

    for (uint i = 0; i < pc.numInstances; i++) {
        BezierInstance inst = instances[i];

        // Transform ray to instance local space (inverse of instance transform)
        // Instance transform: scale -> rotate (XYZ) -> translate
        // Inverse: inverse_translate -> inverse_rotate (ZYX with negated angles) -> inverse_scale
        Ray localRay;
        vec3 translated = worldRay.origin - inst.position;
        localRay.origin = rotateXYZInverse(translated, inst.rotation) / inst.scale;
        localRay.direction = rotateXYZInverse(worldRay.direction, inst.rotation);

        float localTMax = closestT / inst.scale;  // Adjust tMax for scale

        float t, u, v;
        vec3 n;
        if (hitInstance(localRay, tMin / inst.scale, localTMax, t, n, u, v)) {
            // Transform t back to world space
            float worldT = t * inst.scale;
            if (worldT < closestT) {
                hit = true;
                closestT = worldT;
                hitT = worldT;
                // Transform normal back to world space
                hitN = rotateXYZ(n, inst.rotation);
                hitInstanceId = i;
            }
        }
    }

    return hit;
}

// Fresnel reflectance (Schlick approximation)
float fresnel(float cosTheta, float ior) {
    float r0 = (1.0 - ior) / (1.0 + ior);
    r0 = r0 * r0;
    return r0 + (1.0 - r0) * pow(1.0 - cosTheta, 5.0);
}

// Sky/environment color
vec3 skyColor(vec3 dir) {
    float t = 0.5 * (dir.y + 1.0);
    return mix(vec3(1.0), vec3(0.5, 0.7, 1.0), t);
}

// Material types: 0=diffuse, 1=metal, 2=glass
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pc.width) || pixel.y >= int(pc.height)) return;

    vec2 uv = vec2(pixel) / vec2(pc.width, pc.height);
    uv.y = 1.0 - uv.y;

    Ray ray = getCameraRay(uv);
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0);

    // Material properties per instance
    // Instance 0: diffuse ceramic, 1: metal, 2: glass, 3: diffuse
    uint materialTypes[4] = uint[](0, 1, 2, 0);
    vec3 baseColors[4] = vec3[](
        vec3(0.8, 0.6, 0.4),   // Ceramic
        vec3(0.95, 0.93, 0.88), // Silver metal
        vec3(1.0, 1.0, 1.0),   // Glass (white = clear)
        vec3(0.8, 0.4, 0.6)    // Pink ceramic
    );

    const int MAX_BOUNCES = 4;

    for (int bounce = 0; bounce < MAX_BOUNCES; bounce++) {
        float t;
        vec3 normal;
        uint instanceId;

        if (!hitAllInstances(ray, EPSILON, T_MAX, t, normal, instanceId)) {
            color += throughput * skyColor(ray.direction);
            break;
        }

        vec3 hitPoint = ray.origin + t * ray.direction;
        uint matType = materialTypes[instanceId % 4];
        vec3 baseColor = baseColors[instanceId % 4];

        if (matType == 0) {
            // Diffuse - direct lighting only (no GI for speed)
            vec3 lightDir = normalize(vec3(1, 2, 1));
            float NdotL = max(dot(normal, lightDir), 0.0);

            // Shadow ray
            float shadowT;
            vec3 shadowN;
            uint shadowId;
            float shadow = hitAllInstances(Ray(hitPoint + normal * EPSILON * 2.0, lightDir),
                                           EPSILON, T_MAX, shadowT, shadowN, shadowId) ? 0.3 : 1.0;

            color += throughput * baseColor * (0.15 + 0.85 * NdotL * shadow);
            break;  // No further bounces for diffuse

        } else if (matType == 1) {
            // Metal - perfect reflection
            ray.origin = hitPoint + normal * EPSILON * 2.0;
            ray.direction = reflect(ray.direction, normal);
            throughput *= baseColor;

        } else if (matType == 2) {
            // Glass - refraction with Fresnel
            float ior = 1.5;
            float cosTheta = dot(-ray.direction, normal);
            bool entering = cosTheta > 0.0;

            vec3 n = entering ? normal : -normal;
            float eta = entering ? (1.0 / ior) : ior;
            cosTheta = abs(cosTheta);

            float F = fresnel(cosTheta, ior);

            // Simple: reflect if Fresnel says so, else refract
            if (F > 0.5) {
                ray.origin = hitPoint + n * EPSILON * 2.0;
                ray.direction = reflect(ray.direction, n);
            } else {
                vec3 refracted = refract(ray.direction, n, eta);
                if (length(refracted) < 0.5) {
                    // Total internal reflection
                    ray.origin = hitPoint + n * EPSILON * 2.0;
                    ray.direction = reflect(ray.direction, n);
                } else {
                    ray.origin = hitPoint - n * EPSILON * 2.0;
                    ray.direction = refracted;
                }
            }
            throughput *= baseColor;
        }
    }

    color = pow(clamp(color, 0.0, 1.0), vec3(1.0 / 2.2));
    imageStore(outputImage, pixel, vec4(color, 1.0));
}
