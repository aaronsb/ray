#version 450

// Caustic Photon Mapping with Spatial Hashing
// Traces photons from light through glass, accumulates in hash grid using atomics

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants {
    uint gridWidth;        // Ray grid dimensions
    uint gridHeight;
    uint numPrimitives;
    uint numMaterials;
    // Light parameters
    float lightPosX, lightPosY, lightPosZ;
    float lightDirX, lightDirY, lightDirZ;
    float lightIntensity;
    uint lightType;        // 0=directional(sun), 1=point, 2=spot
    float lightRadius;
    // Floor parameters
    float floorY;
    float worldMinX, worldMinZ;
    float worldMaxX, worldMaxZ;
    uint _padMap0, _padMap1;  // Padding for alignment
} pc;

struct CSGPrimitive {
    float x, y, z;
    uint type;
    float param0, param1, param2;
    float _pad;
};

struct CSGTransform {
    float rotX, rotY, rotZ;
    float scale;
};

struct Material {
    float r, g, b;
    uint type;
    float roughness, metallic, ior, emissive;
};  // Must match ray.comp - 32 bytes

layout(std430, binding = 0) readonly buffer Primitives { CSGPrimitive primitives[]; };
layout(std430, binding = 1) readonly buffer Transforms { CSGTransform transforms[]; };
layout(std430, binding = 2) readonly buffer Materials { Material materials[]; };
// RGB caustic buffer - 3 uints per cell for atomic accumulation (R, G, B as fixed-point)
layout(std430, binding = 3) buffer CausticHashMap { uint causticCells[]; };  // [cell*3 + 0]=R, [cell*3 + 1]=G, [cell*3 + 2]=B
layout(std430, binding = 4) readonly buffer PrimToMaterial { uint primMaterialIds[]; };

// 2D grid parameters - direct indexing, no hash collisions
// Must match ray.comp exactly
const float CAUSTIC_WORLD_MIN = -15.0;
const float CAUSTIC_WORLD_MAX = 15.0;
const uint CAUSTIC_GRID_SIZE = 512;  // 512x512 grid
const float CAUSTIC_CELL_SIZE = (CAUSTIC_WORLD_MAX - CAUSTIC_WORLD_MIN) / float(CAUSTIC_GRID_SIZE);

// Direct 2D index from world XZ position (floor is at fixed Y)
// Index = ix * GRID_SIZE + iz (X is major axis)
uint causticIndex2D(vec3 pos) {
    float u = (pos.x - CAUSTIC_WORLD_MIN) / (CAUSTIC_WORLD_MAX - CAUSTIC_WORLD_MIN);
    float v = (pos.z - CAUSTIC_WORLD_MIN) / (CAUSTIC_WORLD_MAX - CAUSTIC_WORLD_MIN);
    uint ix = uint(clamp(u * float(CAUSTIC_GRID_SIZE), 0.0, float(CAUSTIC_GRID_SIZE - 1)));
    uint iz = uint(clamp(v * float(CAUSTIC_GRID_SIZE), 0.0, float(CAUSTIC_GRID_SIZE - 1)));
    return ix * CAUSTIC_GRID_SIZE + iz;  // X major
}

const uint MAT_GLASS = 2;
const uint PRIM_SPHERE = 0;
const uint PRIM_BOX = 1;
const uint PRIM_CYLINDER = 2;
const uint PRIM_CONE = 3;
const uint PRIM_TORUS = 4;

const uint LIGHT_DIRECTIONAL = 0;
const uint LIGHT_POINT = 1;
const uint LIGHT_SPOT = 2;

vec3 refractRay(vec3 I, vec3 N, float eta) {
    float cosi = dot(-I, N);
    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);
    if (k < 0.0) return vec3(0.0);
    return eta * I + (eta * cosi - sqrt(k)) * N;
}

float hitSphere(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b * b - c;
    if (h < 0.0) return -1.0;
    return -b - sqrt(h);
}

float hitSphereFar(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b * b - c;
    if (h < 0.0) return -1.0;
    return -b + sqrt(h);
}

bool hitBox(vec3 ro, vec3 rd, vec3 center, vec3 half_,
            out float tNear, out float tFar, out vec3 normalNear, out vec3 normalFar) {
    // Protect against degenerate rays (e.g., looking straight down Y axis)
    vec3 safeRd = rd;
    float minComp = 1e-6;
    if (abs(safeRd.x) < minComp) safeRd.x = sign(safeRd.x + minComp) * minComp;
    if (abs(safeRd.y) < minComp) safeRd.y = sign(safeRd.y + minComp) * minComp;
    if (abs(safeRd.z) < minComp) safeRd.z = sign(safeRd.z + minComp) * minComp;

    vec3 invRd = 1.0 / safeRd;
    vec3 t1 = (center - half_ - ro) * invRd;
    vec3 t2 = (center + half_ - ro) * invRd;
    vec3 tMin = min(t1, t2);
    vec3 tMax = max(t1, t2);
    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);
    if (tNear > tFar || tFar < 0.0) return false;

    // Entry normal - position-based (which face is the point on?)
    vec3 pNear = ro + tNear * safeRd;
    vec3 localNear = pNear - center;
    vec3 scaledNear = abs(localNear) / half_;
    if (scaledNear.x >= scaledNear.y && scaledNear.x >= scaledNear.z) {
        normalNear = vec3(sign(localNear.x), 0, 0);
    } else if (scaledNear.y >= scaledNear.z) {
        normalNear = vec3(0, sign(localNear.y), 0);
    } else {
        normalNear = vec3(0, 0, sign(localNear.z));
    }

    // Exit normal - position-based
    vec3 pFar = ro + tFar * safeRd;
    vec3 localFar = pFar - center;
    vec3 scaledFar = abs(localFar) / half_;
    if (scaledFar.x >= scaledFar.y && scaledFar.x >= scaledFar.z) {
        normalFar = vec3(sign(localFar.x), 0, 0);
    } else if (scaledFar.y >= scaledFar.z) {
        normalFar = vec3(0, sign(localFar.y), 0);
    } else {
        normalFar = vec3(0, 0, sign(localFar.z));
    }

    return true;
}

// Cylinder intersection (Y-axis aligned, base at center)
bool hitCylinder(vec3 ro, vec3 rd, vec3 center, float radius, float height,
                 out float tNear, out float tFar, out vec3 normalNear, out vec3 normalFar) {
    vec3 oc = ro - center;

    // Infinite cylinder (XZ plane)
    float a = rd.x * rd.x + rd.z * rd.z;
    float b = 2.0 * (oc.x * rd.x + oc.z * rd.z);
    float c = oc.x * oc.x + oc.z * oc.z - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0) return false;

    float t1, t2;
    if (abs(a) < 1e-6) {
        if (c > 0.0) return false;
        t1 = -1e30;
        t2 = 1e30;
    } else {
        float sqrtDisc = sqrt(disc);
        t1 = (-b - sqrtDisc) / (2.0 * a);
        t2 = (-b + sqrtDisc) / (2.0 * a);
    }

    float tCap0, tCap1;
    if (abs(rd.y) < 1e-6) {
        if (oc.y < 0.0 || oc.y > height) return false;
        tCap0 = -1e30;
        tCap1 = 1e30;
    } else {
        tCap0 = (0.0 - oc.y) / rd.y;
        tCap1 = (height - oc.y) / rd.y;
    }
    if (tCap0 > tCap1) { float tmp = tCap0; tCap0 = tCap1; tCap1 = tmp; }

    tNear = max(t1, tCap0);
    tFar = min(t2, tCap1);
    if (tNear > tFar || tFar < 0.0) return false;

    // Compute normals
    vec3 pNear = ro + tNear * rd;
    if (abs(pNear.y - center.y) < 0.001) normalNear = vec3(0, -1, 0);
    else if (abs(pNear.y - center.y - height) < 0.001) normalNear = vec3(0, 1, 0);
    else normalNear = normalize(vec3(pNear.x - center.x, 0, pNear.z - center.z));

    vec3 pFar = ro + tFar * rd;
    if (abs(pFar.y - center.y) < 0.001) normalFar = vec3(0, -1, 0);
    else if (abs(pFar.y - center.y - height) < 0.001) normalFar = vec3(0, 1, 0);
    else normalFar = normalize(vec3(pFar.x - center.x, 0, pFar.z - center.z));

    return true;
}

// Cone intersection (Y-axis, apex at center.y + height)
bool hitCone(vec3 ro, vec3 rd, vec3 center, float radius, float height,
             out float tNear, out float tFar, out vec3 normalNear, out vec3 normalFar) {
    vec3 oc = ro - center;
    float k = radius / height;
    float k2 = k * k;

    float a = rd.x * rd.x + rd.z * rd.z - k2 * rd.y * rd.y;
    float b = 2.0 * (oc.x * rd.x + oc.z * rd.z + k2 * (height - oc.y) * rd.y);
    float c = oc.x * oc.x + oc.z * oc.z - k2 * (height - oc.y) * (height - oc.y);

    float disc = b * b - 4.0 * a * c;

    float tCone1 = 1e30, tCone2 = 1e30, tBase = 1e30;

    // Base cap
    if (abs(rd.y) > 1e-6) {
        float t = -oc.y / rd.y;
        if (t > 1e-6) {
            vec3 p = oc + t * rd;
            if (p.x*p.x + p.z*p.z <= radius*radius) tBase = t;
        }
    }

    // Cone surface
    if (disc >= 0.0 && abs(a) > 1e-6) {
        float sqrtDisc = sqrt(disc);
        float t1 = (-b - sqrtDisc) / (2.0 * a);
        float t2 = (-b + sqrtDisc) / (2.0 * a);

        for (int i = 0; i < 2; i++) {
            float t = (i == 0) ? t1 : t2;
            if (t > 1e-6) {
                vec3 p = oc + t * rd;
                if (p.y >= -0.01 && p.y <= height + 0.01) {
                    float r = length(vec2(p.x, p.z));
                    float expectedR = k * (height - p.y);
                    if (abs(r - expectedR) < 0.1) {
                        if (tCone1 > 1e20) tCone1 = t;
                        else tCone2 = t;
                    }
                }
            }
        }
    }
    if (tCone1 > tCone2) { float tmp = tCone1; tCone1 = tCone2; tCone2 = tmp; }

    // Combine hits
    int enterType = -1, exitType = -1;
    tNear = 1e30; tFar = -1e30;

    if (tCone1 < 1e20 && tCone2 < 1e20) {
        tNear = tCone1; tFar = tCone2;
        enterType = 0; exitType = 0;
    } else if (tCone1 < 1e20 && tBase < 1e20) {
        if (tCone1 < tBase) { tNear = tCone1; tFar = tBase; enterType = 0; exitType = 1; }
        else { tNear = tBase; tFar = tCone1; enterType = 1; exitType = 0; }
    } else {
        return false;
    }

    if (tNear >= tFar || tFar < 0.0) return false;

    // Normals
    float cosAngle = height / sqrt(height * height + radius * radius);
    float sinAngle = radius / sqrt(height * height + radius * radius);

    vec3 pNear = oc + tNear * rd;
    vec3 pFar = oc + tFar * rd;

    if (enterType == 1) normalNear = vec3(0, -1, 0);
    else {
        float radLen = length(vec2(pNear.x, pNear.z));
        if (radLen < 1e-6) normalNear = vec3(0, 1, 0);
        else {
            vec2 radDir = vec2(pNear.x, pNear.z) / radLen;
            normalNear = normalize(vec3(radDir.x * cosAngle, sinAngle, radDir.y * cosAngle));
        }
    }

    if (exitType == 1) normalFar = vec3(0, -1, 0);
    else {
        float radLen = length(vec2(pFar.x, pFar.z));
        if (radLen < 1e-6) normalFar = vec3(0, 1, 0);
        else {
            vec2 radDir = vec2(pFar.x, pFar.z) / radLen;
            normalFar = normalize(vec3(radDir.x * cosAngle, sinAngle, radDir.y * cosAngle));
        }
    }

    return true;
}

// Torus SDF
float torusSDF(vec3 p, float R, float r) {
    vec2 q = vec2(length(p.xz) - R, p.y);
    return length(q) - r;
}

// Torus intersection using sphere tracing
bool hitTorus(vec3 ro, vec3 rd, vec3 center, float majorR, float minorR,
              out float tNear, out float tFar, out vec3 normalNear, out vec3 normalFar) {
    vec3 O = ro - center;

    // Bounding sphere check
    float boundR = majorR + minorR;
    float aDot = dot(rd, rd);
    float bDot = 2.0 * dot(O, rd);
    float cDot = dot(O, O) - boundR * boundR;
    float disc = bDot * bDot - 4.0 * aDot * cDot;
    if (disc < 0.0) return false;

    float sqrtDisc = sqrt(disc);
    float t0 = (-bDot - sqrtDisc) / (2.0 * aDot);
    float t1 = (-bDot + sqrtDisc) / (2.0 * aDot);
    if (t1 < 0.001) return false;

    float tStart = max(t0, 0.001);
    float tEnd = t1;

    // Sphere trace to find entry
    tNear = -1.0;
    float t = tStart;
    for (int i = 0; i < 64; i++) {
        vec3 p = O + t * rd;
        float d = torusSDF(p, majorR, minorR);
        if (d < 0.0001) { tNear = t; break; }
        t += d;
        if (t > tEnd) break;
    }
    if (tNear < 0.0) return false;

    // Sphere trace backwards for exit
    tFar = -1.0;
    t = tEnd;
    for (int i = 0; i < 64; i++) {
        vec3 p = O + t * rd;
        float d = torusSDF(p, majorR, minorR);
        if (d < 0.0001) { tFar = t; break; }
        t -= d;
        if (t <= tNear + 0.001) break;
    }

    // Forward march fallback
    if (tFar < 0.0 || tFar <= tNear) {
        t = tNear + 0.0001;
        for (int i = 0; i < 128; i++) {
            vec3 p = O + t * rd;
            float d = torusSDF(p, majorR, minorR);
            if (d > 0.0) {
                float lo = tNear, hi = t;
                for (int j = 0; j < 16; j++) {
                    float mid = 0.5 * (lo + hi);
                    if (torusSDF(O + mid * rd, majorR, minorR) < 0.0) lo = mid;
                    else hi = mid;
                }
                tFar = 0.5 * (lo + hi);
                break;
            }
            t += max(-d, 0.0001);
            if (t > tEnd) break;
        }
    }
    if (tFar < 0.0 || tFar <= tNear) return false;

    // Compute normals
    vec3 pNear = O + tNear * rd;
    vec3 pFar = O + tFar * rd;

    float sqrtXZ1 = sqrt(pNear.x * pNear.x + pNear.z * pNear.z + 1e-8);
    normalNear = normalize(vec3(
        (sqrtXZ1 - majorR) * pNear.x / sqrtXZ1,
        pNear.y,
        (sqrtXZ1 - majorR) * pNear.z / sqrtXZ1
    ));

    float sqrtXZ2 = sqrt(pFar.x * pFar.x + pFar.z * pFar.z + 1e-8);
    normalFar = normalize(vec3(
        (sqrtXZ2 - majorR) * pFar.x / sqrtXZ2,
        pFar.y,
        (sqrtXZ2 - majorR) * pFar.z / sqrtXZ2
    ));

    return true;
}

// Trace ray through glass, return floor hit position (vec3(-1000) if no hit)
// Also returns: primitive index, path length through glass, material ID
vec3 tracePhoton(vec3 ro, vec3 rd, out int hitPrimitive, out float pathLength, out uint matId) {
    hitPrimitive = -1;
    pathLength = 0.0;
    matId = 0;
    // Find closest glass primitive
    float bestT = 1e10;
    int bestPrim = -1;

    for (uint i = 0; i < pc.numPrimitives; i++) {
        uint matId = primMaterialIds[i];
        if (matId >= pc.numMaterials) continue;
        if (materials[matId].type != MAT_GLASS) continue;

        CSGPrimitive prim = primitives[i];
        CSGTransform xform = transforms[i];
        vec3 center = vec3(prim.x, prim.y, prim.z);
        float scale = xform.scale;

        float t = -1.0;
        if (prim.type == PRIM_SPHERE) {
            t = hitSphere(ro, rd, center, prim.param0 * scale);
        } else if (prim.type == PRIM_BOX) {
            vec3 half_ = vec3(prim.param0, prim.param1, prim.param2) * scale;
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitBox(ro, rd, center, half_, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_CYLINDER) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitCylinder(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_CONE) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitCone(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_TORUS) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitTorus(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        }

        if (t > 0.0 && t < bestT) {
            bestT = t;
            bestPrim = int(i);
        }
    }

    if (bestPrim < 0) return vec3(-1000.0);  // Sentinel for "no hit"

    hitPrimitive = bestPrim;  // Return which primitive was hit
    matId = primMaterialIds[bestPrim];  // Return material ID for Beer's law

    // Trace through glass
    CSGPrimitive prim = primitives[bestPrim];
    CSGTransform xform = transforms[bestPrim];
    vec3 center = vec3(prim.x, prim.y, prim.z);
    float scale = xform.scale;

    float ior = materials[matId].ior > 1.0 ? materials[matId].ior : 1.5;

    vec3 hitEntry = ro + rd * bestT;
    vec3 normalEntry, normalExit, hitExit;
    vec3 refracted;

    if (prim.type == PRIM_SPHERE) {
        float radius = prim.param0 * scale;
        normalEntry = normalize(hitEntry - center);

        refracted = refractRay(rd, normalEntry, 1.0 / ior);
        if (length(refracted) < 0.5) return vec3(-1000.0);

        float tExit = hitSphereFar(hitEntry + refracted * 0.001, refracted, center, radius);
        if (tExit < 0.0) return vec3(-1000.0);

        hitExit = hitEntry + refracted * (tExit + 0.001);
        normalExit = normalize(hitExit - center);
    } else if (prim.type == PRIM_BOX) {
        vec3 half_ = vec3(prim.param0, prim.param1, prim.param2) * scale;
        float tNear, tFar;
        vec3 nNear, nFar;
        hitBox(ro, rd, center, half_, tNear, tFar, nNear, nFar);
        normalEntry = nNear;

        refracted = refractRay(rd, normalEntry, 1.0 / ior);
        if (length(refracted) < 0.5) return vec3(-1000.0);

        // For box: compute exit directly using the original ray's tFar
        // This avoids the second hitBox call which can cause multi-bounce artifacts
        hitExit = ro + rd * tFar;  // Exit point from original entry ray

        // But we need the exit point for the REFRACTED ray, not the original
        // Use slab intersection directly for the refracted ray
        vec3 invRef = 1.0 / (refracted + vec3(1e-8));  // Avoid division by zero
        vec3 t1 = (center - half_ - hitEntry) * invRef;
        vec3 t2 = (center + half_ - hitEntry) * invRef;
        vec3 tMax = max(t1, t2);
        float tExit = min(min(tMax.x, tMax.y), tMax.z);

        if (tExit < 0.001) return vec3(-1000.0);  // No valid exit

        hitExit = hitEntry + refracted * tExit;

        // Exit normal from position
        vec3 local = hitExit - center;
        vec3 normHalf = abs(local) / half_;
        if (normHalf.x >= normHalf.y && normHalf.x >= normHalf.z) {
            normalExit = vec3(sign(local.x), 0.0, 0.0);
        } else if (normHalf.y >= normHalf.z) {
            normalExit = vec3(0.0, sign(local.y), 0.0);
        } else {
            normalExit = vec3(0.0, 0.0, sign(local.z));
        }

        hitExit = hitExit + normalExit * 0.001;  // Push slightly outside
    } else if (prim.type == PRIM_CYLINDER) {
        float radius = prim.param0 * scale;
        float height = prim.param1 * scale;
        float tNear, tFar;
        vec3 nNear, nFar;
        hitCylinder(ro, rd, center, radius, height, tNear, tFar, nNear, nFar);
        normalEntry = nNear;

        refracted = refractRay(rd, normalEntry, 1.0 / ior);
        if (length(refracted) < 0.5) return vec3(-1000.0);

        float tN2, tF2;
        vec3 nN2, nF2;
        if (!hitCylinder(hitEntry + refracted * 0.01, refracted, center, radius, height, tN2, tF2, nN2, nF2)) {
            return vec3(-1000.0);
        }

        hitExit = hitEntry + refracted * (tF2 + 0.01);
        normalExit = nF2;
    } else if (prim.type == PRIM_CONE) {
        float radius = prim.param0 * scale;
        float height = prim.param1 * scale;
        float tNear, tFar;
        vec3 nNear, nFar;
        hitCone(ro, rd, center, radius, height, tNear, tFar, nNear, nFar);
        normalEntry = nNear;

        refracted = refractRay(rd, normalEntry, 1.0 / ior);
        if (length(refracted) < 0.5) return vec3(-1000.0);

        float tN2, tF2;
        vec3 nN2, nF2;
        if (!hitCone(hitEntry + refracted * 0.01, refracted, center, radius, height, tN2, tF2, nN2, nF2)) {
            return vec3(-1000.0);
        }

        hitExit = hitEntry + refracted * (tF2 + 0.01);
        normalExit = nF2;
    } else if (prim.type == PRIM_TORUS) {
        float majorR = prim.param0 * scale;
        float minorR = prim.param1 * scale;
        float tNear, tFar;
        vec3 nNear, nFar;
        hitTorus(ro, rd, center, majorR, minorR, tNear, tFar, nNear, nFar);
        normalEntry = nNear;

        refracted = refractRay(rd, normalEntry, 1.0 / ior);
        if (length(refracted) < 0.5) return vec3(-1000.0);

        float tN2, tF2;
        vec3 nN2, nF2;
        if (!hitTorus(hitEntry + refracted * 0.01, refracted, center, majorR, minorR, tN2, tF2, nN2, nF2)) {
            return vec3(-1000.0);
        }

        hitExit = hitEntry + refracted * (tF2 + 0.01);
        normalExit = nF2;
    } else {
        return vec3(-1000.0);  // Unknown primitive type
    }

    // Calculate path length through glass for Beer's law
    pathLength = length(hitExit - hitEntry);

    // Refract out
    vec3 exitDir = refractRay(refracted, -normalExit, ior);
    if (length(exitDir) < 0.5) return vec3(-1000.0);
    exitDir = normalize(exitDir);

    // Hit floor
    if (abs(exitDir.y) < 0.001) return vec3(-1000.0);
    float tFloor = (pc.floorY - hitExit.y) / exitDir.y;
    if (tFloor < 0.0 || tFloor > 100.0) return vec3(-1000.0);

    return hitExit + exitDir * tFloor;
}

// (CAUSTIC_WORLD_MIN/MAX defined at top of file)

void main() {
    ivec2 rayIdx = ivec2(gl_GlobalInvocationID.xy);
    if (rayIdx.x >= int(pc.gridWidth) || rayIdx.y >= int(pc.gridHeight)) return;

    // Normalized grid coordinates [-1, 1]
    float u = (float(rayIdx.x) / float(pc.gridWidth - 1)) * 2.0 - 1.0;
    float v = (float(rayIdx.y) / float(pc.gridHeight - 1)) * 2.0 - 1.0;

    vec3 lightDir = normalize(vec3(pc.lightDirX, pc.lightDirY, pc.lightDirZ));
    vec3 lightPos = vec3(pc.lightPosX, pc.lightPosY, pc.lightPosZ);

    // Build orthonormal basis for light
    vec3 up = abs(lightDir.y) > 0.99 ? vec3(1, 0, 0) : vec3(0, 1, 0);
    vec3 right = normalize(cross(up, lightDir));
    vec3 forward = cross(lightDir, right);

    vec3 ro, rd;
    float raySpacing;

    if (pc.lightType == LIGHT_DIRECTIONAL) {
        // Directional: parallel rays covering world XZ bounds
        // Offset ray origins to account for light angle hitting objects at different heights
        float extent = 20.0;  // Cover Â±20 world units
        raySpacing = extent * 2.0 / float(pc.gridWidth);

        // Start high and offset in opposite direction of light travel
        // so rays passing through objects land on the floor within bounds
        float startY = 100.0;
        vec3 offset = -lightDir * 80.0;  // Move origin back along light direction
        ro = vec3(u * extent, 0.0, v * extent) + offset;
        ro.y = startY;
        rd = lightDir;
    } else if (pc.lightType == LIGHT_POINT) {
        // Point light: rays emanate from point in hemisphere toward floor
        float angle = 0.8;  // Cone half-angle
        rd = normalize(lightDir + right * u * angle + forward * v * angle);
        ro = lightPos;
        raySpacing = angle * 2.0 / float(pc.gridWidth);
    } else {
        // Spot light: rays within cone
        float angle = pc.lightRadius;  // Cone half-angle in radians
        rd = normalize(lightDir + right * u * angle + forward * v * angle);
        ro = lightPos;
        raySpacing = angle * 2.0 / float(pc.gridWidth);
    }

    // DEBUG: Test ray coverage by computing direct floor hit (bypass glass tracing)
    // Remove this debug block after testing
    #if 0
    {
        // Direct floor hit without glass
        float tFloor = (pc.floorY - ro.y) / rd.y;
        if (tFloor > 0.0) {
            vec3 floorHit = ro + rd * tFloor;
            if (floorHit.x >= CAUSTIC_WORLD_MIN && floorHit.x <= CAUSTIC_WORLD_MAX &&
                floorHit.z >= CAUSTIC_WORLD_MIN && floorHit.z <= CAUSTIC_WORLD_MAX) {
                uint debugIdx = causticIndex2D(floorHit);
                atomicAdd(causticCells[debugIdx], 100);
            }
        }
        return;  // Skip glass tracing for debug
    }
    #endif

    // Trace center ray (returns vec3(-1000) for no hit)
    int primCenter, primRight, primUp;
    float pathCenter, pathRight, pathUp;
    uint matCenter, matRight, matUp;
    vec3 hitCenter = tracePhoton(ro, rd, primCenter, pathCenter, matCenter);
    if (hitCenter.x < -100.0) return;  // Check for sentinel, not negative coords

    // Check if hit is within our map bounds (fixed bounds matching ray.comp)
    if (hitCenter.x < CAUSTIC_WORLD_MIN || hitCenter.x > CAUSTIC_WORLD_MAX ||
        hitCenter.z < CAUSTIC_WORLD_MIN || hitCenter.z > CAUSTIC_WORLD_MAX) {
        return;
    }

    // Compute area ratio using neighboring rays
    // For directional light with XZ grid, neighbors are simply +X and +Z
    vec3 roRight = (pc.lightType == LIGHT_DIRECTIONAL) ? ro + vec3(raySpacing, 0.0, 0.0) : ro + right * raySpacing;
    vec3 roUp = (pc.lightType == LIGHT_DIRECTIONAL) ? ro + vec3(0.0, 0.0, raySpacing) : ro + forward * raySpacing;

    // For point/spot, direction also changes
    vec3 rdRight = rd, rdUp = rd;
    if (pc.lightType != LIGHT_DIRECTIONAL) {
        float du = 1.0 / float(pc.gridWidth - 1) * 2.0;
        float angle = (pc.lightType == LIGHT_SPOT) ? pc.lightRadius : 0.8;
        rdRight = normalize(lightDir + right * (u + du) * angle + forward * v * angle);
        rdUp = normalize(lightDir + right * u * angle + forward * (v + du) * angle);
    }

    vec3 hitRight = tracePhoton(roRight, rdRight, primRight, pathRight, matRight);
    vec3 hitUp = tracePhoton(roUp, rdUp, primUp, pathUp, matUp);

    // Require all 3 rays to trace through glass (can be different primitives)
    if (hitRight.x < -100.0 || hitUp.x < -100.0) {
        return;  // Neighbor missed glass entirely
    }

    // Check floor position continuity - reject if neighbors land too far apart
    // This catches face transitions within a single primitive (esp. boxes)
    // where neighboring rays hit different faces and refract very differently
    float distRight = length(hitRight - hitCenter);
    float distUp = length(hitUp - hitCenter);
    float maxDist = raySpacing * 5.0;  // Allow some focusing but reject discontinuities
    if (distRight > maxDist || distUp > maxDist) {
        return;  // Floor positions too far apart - likely face transition artifact
    }

    // Compute area compression
    vec3 dRight = hitRight - hitCenter;
    vec3 dUp = hitUp - hitCenter;
    float refractedArea = length(cross(dRight, dUp));

    float origArea = raySpacing * raySpacing;

    // Filter out degenerate cases (extreme focusing or divergence)
    if (refractedArea < 0.0001 || refractedArea > origArea * 100.0) {
        return;  // Skip outliers that would create bright dots
    }

    float intensity = origArea / refractedArea;
    intensity = clamp(intensity, 0.0, 10.0);  // Tighter clamp to avoid hotspots

    // For point/spot lights, also apply distance falloff
    if (pc.lightType != LIGHT_DIRECTIONAL) {
        float dist = length(hitCenter - lightPos);
        intensity /= (1.0 + dist * dist * 0.01);
    }

    // Apply Beer's law for colored glass absorption
    // absorption = -log(color) gives us absorption coefficient from transmission color
    // transmitted = exp(-absorption * distance)
    Material mat = materials[matCenter];
    vec3 glassColor = vec3(mat.r, mat.g, mat.b);

    // Convert color to absorption (avoid log(0) with small epsilon)
    // Higher color value = less absorption = more transmission
    vec3 absorption = -log(max(glassColor, vec3(0.01)));

    // Apply Beer's law: transmission decreases exponentially with path length
    // Scale path length for reasonable absorption (typical sphere diameter ~2)
    float absorptionScale = 0.5;  // Tunable: higher = more color saturation
    vec3 transmission = exp(-absorption * pathCenter * absorptionScale);

    // Compute RGB contribution (scale for fixed-point storage)
    vec3 rgbContribution = transmission * intensity * pc.lightIntensity * 1000.0;
    uvec3 fixedRGB = uvec3(clamp(rgbContribution, vec3(0.0), vec3(1000000.0)));

    if (fixedRGB.r == 0u && fixedRGB.g == 0u && fixedRGB.b == 0u) return;

    // Atomic accumulate RGB to 2D grid cell (3 uints per cell)
    uint cellIndex = causticIndex2D(hitCenter);
    atomicAdd(causticCells[cellIndex * 3u + 0u], fixedRGB.r);
    atomicAdd(causticCells[cellIndex * 3u + 1u], fixedRGB.g);
    atomicAdd(causticCells[cellIndex * 3u + 2u], fixedRGB.b);
}
