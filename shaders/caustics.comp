#version 450

// Caustic Photon Mapping with Spatial Hashing
// Traces photons from light through dielectrics, accumulates in hash grid using atomics

layout(local_size_x = 16, local_size_y = 16) in;

layout(push_constant) uniform PushConstants {
    uint gridWidth;        // Ray grid dimensions
    uint gridHeight;
    uint numPrimitives;
    uint numMaterials;
    // Light parameters
    float lightPosX, lightPosY, lightPosZ;
    float lightDirX, lightDirY, lightDirZ;
    float lightIntensity;
    uint lightType;        // 0=directional(sun), 1=point, 2=spot
    float lightRadius;
    // Floor parameters
    float floorY;
    // Patch data
    uint numPatches;
    uint numBVHNodes;
    uint numInstances;
    uint _pad0;
    // Camera position - ray grid centers near camera for focused caustics
    float camPosX, camPosY, camPosZ;
    float _pad1;
} pc;

struct CSGPrimitive {
    float x, y, z;
    uint type;
    float param0, param1, param2;
    float _pad;
};

struct CSGTransform {
    float rotX, rotY, rotZ;
    float scale;
};

struct Material {
    float r, g, b;
    uint type;
    float roughness, metallic, ior, emissive;
};  // Must match ray.comp - 32 bytes

layout(std430, binding = 0) readonly buffer Primitives { CSGPrimitive primitives[]; };
layout(std430, binding = 1) readonly buffer Transforms { CSGTransform transforms[]; };
layout(std430, binding = 2) readonly buffer Materials { Material materials[]; };
// RGB caustic buffer - 3 uints per cell for atomic accumulation (R, G, B as fixed-point)
layout(std430, binding = 3) buffer CausticHashMap { uint causticCells[]; };  // [cell*3 + 0]=R, [cell*3 + 1]=G, [cell*3 + 2]=B
layout(std430, binding = 4) readonly buffer PrimToMaterial { uint primMaterialIds[]; };

// Bezier patch data (for dielectric teapots, etc.)
// 16 vec4s per patch (control points, w unused)
layout(std430, binding = 5) readonly buffer PatchBuffer { vec4 patchData[]; };

// BVH nodes for patches (64 bytes each)
struct BVHNode {
    float minX, minY, minZ;
    uint leftOrFirst;
    float maxX, maxY, maxZ;
    uint rightOrCount;
};
layout(std430, binding = 6) readonly buffer BVHBuffer { BVHNode bvhNodes[]; };

// Bezier instances (transforms + material)
struct BezierInstance {
    vec3 position;
    float scale;
    vec3 rotation;  // Euler angles (radians)
    uint materialId;
};
layout(std430, binding = 7) readonly buffer InstanceBuffer { BezierInstance instances[]; };

// ============================================================================
// Rotation utilities (must match ray.comp)
// ============================================================================
mat3 buildRotationMatrix(float rx, float ry, float rz) {
    float cx = cos(rx), sx = sin(rx);
    float cy = cos(ry), sy = sin(ry);
    float cz = cos(rz), sz = sin(rz);
    return mat3(
        cy*cz, sx*sy*cz + cx*sz, -cx*sy*cz + sx*sz,
        -cy*sz, -sx*sy*sz + cx*cz, cx*sy*sz + sx*cz,
        sy, -sx*cy, cx*cy
    );
}

vec3 rotateXYZ(vec3 p, vec3 angles) {
    return buildRotationMatrix(angles.x, angles.y, angles.z) * p;
}

vec3 rotateXYZInverse(vec3 p, vec3 angles) {
    return transpose(buildRotationMatrix(angles.x, angles.y, angles.z)) * p;
}

// 3D spatial hashing parameters - must match ray.comp exactly
const float CAUSTIC_CELL_SIZE = 0.08;  // World units per cell (~8cm)
const uint CAUSTIC_HASH_SIZE = 4194304;  // 4M cells for hash table

// Get cell coordinates for a world position
ivec3 causticGetCell3D(vec3 pos) {
    return ivec3(floor(pos / CAUSTIC_CELL_SIZE));
}

// Hash from cell coordinates directly
uint cellHash3D(ivec3 cell) {
    uint hash = uint(cell.x) * 73856093u ^
                uint(cell.y) * 19349663u ^
                uint(cell.z) * 83492791u;
    return hash % CAUSTIC_HASH_SIZE;
}

// Cell signature: pack cell coords for collision validation
// Uses 10 bits per axis (range -512 to +511 cells = ±25.6 world units)
// High bit set to distinguish from empty (0)
uint cellSignature(ivec3 cell) {
    uint px = uint(cell.x + 512) & 0x3FFu;
    uint py = uint(cell.y + 512) & 0x3FFu;
    uint pz = uint(cell.z + 512) & 0x3FFu;
    return (px) | (py << 10) | (pz << 20) | 0x80000000u;
}

const uint MAT_GLASS = 2;
const uint PRIM_SPHERE = 0;
const uint PRIM_BOX = 1;
const uint PRIM_CYLINDER = 2;
const uint PRIM_CONE = 3;
const uint PRIM_TORUS = 4;

const uint LIGHT_DIRECTIONAL = 0;
const uint LIGHT_POINT = 1;
const uint LIGHT_SPOT = 2;

vec3 refractRay(vec3 I, vec3 N, float eta) {
    float cosi = dot(-I, N);
    float k = 1.0 - eta * eta * (1.0 - cosi * cosi);
    if (k < 0.0) return vec3(0.0);
    return eta * I + (eta * cosi - sqrt(k)) * N;
}

float hitSphere(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b * b - c;
    if (h < 0.0) return -1.0;
    return -b - sqrt(h);
}

float hitSphereFar(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b * b - c;
    if (h < 0.0) return -1.0;
    return -b + sqrt(h);
}

bool hitBox(vec3 ro, vec3 rd, vec3 center, vec3 half_,
            out float tNear, out float tFar, out vec3 normalNear, out vec3 normalFar) {
    // Protect against degenerate rays (e.g., looking straight down Y axis)
    vec3 safeRd = rd;
    float minComp = 1e-6;
    if (abs(safeRd.x) < minComp) safeRd.x = sign(safeRd.x + minComp) * minComp;
    if (abs(safeRd.y) < minComp) safeRd.y = sign(safeRd.y + minComp) * minComp;
    if (abs(safeRd.z) < minComp) safeRd.z = sign(safeRd.z + minComp) * minComp;

    vec3 invRd = 1.0 / safeRd;
    vec3 t1 = (center - half_ - ro) * invRd;
    vec3 t2 = (center + half_ - ro) * invRd;
    vec3 tMin = min(t1, t2);
    vec3 tMax = max(t1, t2);
    tNear = max(max(tMin.x, tMin.y), tMin.z);
    tFar = min(min(tMax.x, tMax.y), tMax.z);
    if (tNear > tFar || tFar < 0.0) return false;

    // Entry normal - position-based (which face is the point on?)
    vec3 pNear = ro + tNear * safeRd;
    vec3 localNear = pNear - center;
    vec3 scaledNear = abs(localNear) / half_;
    if (scaledNear.x >= scaledNear.y && scaledNear.x >= scaledNear.z) {
        normalNear = vec3(sign(localNear.x), 0, 0);
    } else if (scaledNear.y >= scaledNear.z) {
        normalNear = vec3(0, sign(localNear.y), 0);
    } else {
        normalNear = vec3(0, 0, sign(localNear.z));
    }

    // Exit normal - position-based
    vec3 pFar = ro + tFar * safeRd;
    vec3 localFar = pFar - center;
    vec3 scaledFar = abs(localFar) / half_;
    if (scaledFar.x >= scaledFar.y && scaledFar.x >= scaledFar.z) {
        normalFar = vec3(sign(localFar.x), 0, 0);
    } else if (scaledFar.y >= scaledFar.z) {
        normalFar = vec3(0, sign(localFar.y), 0);
    } else {
        normalFar = vec3(0, 0, sign(localFar.z));
    }

    return true;
}

// Cylinder intersection (Y-axis aligned, base at center)
bool hitCylinder(vec3 ro, vec3 rd, vec3 center, float radius, float height,
                 out float tNear, out float tFar, out vec3 normalNear, out vec3 normalFar) {
    vec3 oc = ro - center;

    // Infinite cylinder (XZ plane)
    float a = rd.x * rd.x + rd.z * rd.z;
    float b = 2.0 * (oc.x * rd.x + oc.z * rd.z);
    float c = oc.x * oc.x + oc.z * oc.z - radius * radius;

    float disc = b * b - 4.0 * a * c;
    if (disc < 0.0) return false;

    float t1, t2;
    if (abs(a) < 1e-6) {
        if (c > 0.0) return false;
        t1 = -1e30;
        t2 = 1e30;
    } else {
        float sqrtDisc = sqrt(disc);
        t1 = (-b - sqrtDisc) / (2.0 * a);
        t2 = (-b + sqrtDisc) / (2.0 * a);
    }

    float tCap0, tCap1;
    if (abs(rd.y) < 1e-6) {
        if (oc.y < 0.0 || oc.y > height) return false;
        tCap0 = -1e30;
        tCap1 = 1e30;
    } else {
        tCap0 = (0.0 - oc.y) / rd.y;
        tCap1 = (height - oc.y) / rd.y;
    }
    if (tCap0 > tCap1) { float tmp = tCap0; tCap0 = tCap1; tCap1 = tmp; }

    tNear = max(t1, tCap0);
    tFar = min(t2, tCap1);
    if (tNear > tFar || tFar < 0.0) return false;

    // Compute normals
    vec3 pNear = ro + tNear * rd;
    if (abs(pNear.y - center.y) < 0.001) normalNear = vec3(0, -1, 0);
    else if (abs(pNear.y - center.y - height) < 0.001) normalNear = vec3(0, 1, 0);
    else normalNear = normalize(vec3(pNear.x - center.x, 0, pNear.z - center.z));

    vec3 pFar = ro + tFar * rd;
    if (abs(pFar.y - center.y) < 0.001) normalFar = vec3(0, -1, 0);
    else if (abs(pFar.y - center.y - height) < 0.001) normalFar = vec3(0, 1, 0);
    else normalFar = normalize(vec3(pFar.x - center.x, 0, pFar.z - center.z));

    return true;
}

// Cone intersection (Y-axis, apex at center.y + height)
bool hitCone(vec3 ro, vec3 rd, vec3 center, float radius, float height,
             out float tNear, out float tFar, out vec3 normalNear, out vec3 normalFar) {
    vec3 oc = ro - center;
    float k = radius / height;
    float k2 = k * k;

    float a = rd.x * rd.x + rd.z * rd.z - k2 * rd.y * rd.y;
    float b = 2.0 * (oc.x * rd.x + oc.z * rd.z + k2 * (height - oc.y) * rd.y);
    float c = oc.x * oc.x + oc.z * oc.z - k2 * (height - oc.y) * (height - oc.y);

    float disc = b * b - 4.0 * a * c;

    float tCone1 = 1e30, tCone2 = 1e30, tBase = 1e30;

    // Base cap
    if (abs(rd.y) > 1e-6) {
        float t = -oc.y / rd.y;
        if (t > 1e-6) {
            vec3 p = oc + t * rd;
            if (p.x*p.x + p.z*p.z <= radius*radius) tBase = t;
        }
    }

    // Cone surface
    if (disc >= 0.0 && abs(a) > 1e-6) {
        float sqrtDisc = sqrt(disc);
        float t1 = (-b - sqrtDisc) / (2.0 * a);
        float t2 = (-b + sqrtDisc) / (2.0 * a);

        for (int i = 0; i < 2; i++) {
            float t = (i == 0) ? t1 : t2;
            if (t > 1e-6) {
                vec3 p = oc + t * rd;
                if (p.y >= -0.01 && p.y <= height + 0.01) {
                    float r = length(vec2(p.x, p.z));
                    float expectedR = k * (height - p.y);
                    if (abs(r - expectedR) < 0.1) {
                        if (tCone1 > 1e20) tCone1 = t;
                        else tCone2 = t;
                    }
                }
            }
        }
    }
    if (tCone1 > tCone2) { float tmp = tCone1; tCone1 = tCone2; tCone2 = tmp; }

    // Combine hits
    int enterType = -1, exitType = -1;
    tNear = 1e30; tFar = -1e30;

    if (tCone1 < 1e20 && tCone2 < 1e20) {
        tNear = tCone1; tFar = tCone2;
        enterType = 0; exitType = 0;
    } else if (tCone1 < 1e20 && tBase < 1e20) {
        if (tCone1 < tBase) { tNear = tCone1; tFar = tBase; enterType = 0; exitType = 1; }
        else { tNear = tBase; tFar = tCone1; enterType = 1; exitType = 0; }
    } else {
        return false;
    }

    if (tNear >= tFar || tFar < 0.0) return false;

    // Normals
    float cosAngle = height / sqrt(height * height + radius * radius);
    float sinAngle = radius / sqrt(height * height + radius * radius);

    vec3 pNear = oc + tNear * rd;
    vec3 pFar = oc + tFar * rd;

    if (enterType == 1) normalNear = vec3(0, -1, 0);
    else {
        float radLen = length(vec2(pNear.x, pNear.z));
        if (radLen < 1e-6) normalNear = vec3(0, 1, 0);
        else {
            vec2 radDir = vec2(pNear.x, pNear.z) / radLen;
            normalNear = normalize(vec3(radDir.x * cosAngle, sinAngle, radDir.y * cosAngle));
        }
    }

    if (exitType == 1) normalFar = vec3(0, -1, 0);
    else {
        float radLen = length(vec2(pFar.x, pFar.z));
        if (radLen < 1e-6) normalFar = vec3(0, 1, 0);
        else {
            vec2 radDir = vec2(pFar.x, pFar.z) / radLen;
            normalFar = normalize(vec3(radDir.x * cosAngle, sinAngle, radDir.y * cosAngle));
        }
    }

    return true;
}

// Torus SDF
float torusSDF(vec3 p, float R, float r) {
    vec2 q = vec2(length(p.xz) - R, p.y);
    return length(q) - r;
}

// Torus intersection using sphere tracing
bool hitTorus(vec3 ro, vec3 rd, vec3 center, float majorR, float minorR,
              out float tNear, out float tFar, out vec3 normalNear, out vec3 normalFar) {
    vec3 O = ro - center;

    // Bounding sphere check
    float boundR = majorR + minorR;
    float aDot = dot(rd, rd);
    float bDot = 2.0 * dot(O, rd);
    float cDot = dot(O, O) - boundR * boundR;
    float disc = bDot * bDot - 4.0 * aDot * cDot;
    if (disc < 0.0) return false;

    float sqrtDisc = sqrt(disc);
    float t0 = (-bDot - sqrtDisc) / (2.0 * aDot);
    float t1 = (-bDot + sqrtDisc) / (2.0 * aDot);
    if (t1 < 0.001) return false;

    float tStart = max(t0, 0.001);
    float tEnd = t1;

    // Sphere trace to find entry
    tNear = -1.0;
    float t = tStart;
    for (int i = 0; i < 64; i++) {
        vec3 p = O + t * rd;
        float d = torusSDF(p, majorR, minorR);
        if (d < 0.0001) { tNear = t; break; }
        t += d;
        if (t > tEnd) break;
    }
    if (tNear < 0.0) return false;

    // Sphere trace backwards for exit
    tFar = -1.0;
    t = tEnd;
    for (int i = 0; i < 64; i++) {
        vec3 p = O + t * rd;
        float d = torusSDF(p, majorR, minorR);
        if (d < 0.0001) { tFar = t; break; }
        t -= d;
        if (t <= tNear + 0.001) break;
    }

    // Forward march fallback
    if (tFar < 0.0 || tFar <= tNear) {
        t = tNear + 0.0001;
        for (int i = 0; i < 128; i++) {
            vec3 p = O + t * rd;
            float d = torusSDF(p, majorR, minorR);
            if (d > 0.0) {
                float lo = tNear, hi = t;
                for (int j = 0; j < 16; j++) {
                    float mid = 0.5 * (lo + hi);
                    if (torusSDF(O + mid * rd, majorR, minorR) < 0.0) lo = mid;
                    else hi = mid;
                }
                tFar = 0.5 * (lo + hi);
                break;
            }
            t += max(-d, 0.0001);
            if (t > tEnd) break;
        }
    }
    if (tFar < 0.0 || tFar <= tNear) return false;

    // Compute normals
    vec3 pNear = O + tNear * rd;
    vec3 pFar = O + tFar * rd;

    float sqrtXZ1 = sqrt(pNear.x * pNear.x + pNear.z * pNear.z + 1e-8);
    normalNear = normalize(vec3(
        (sqrtXZ1 - majorR) * pNear.x / sqrtXZ1,
        pNear.y,
        (sqrtXZ1 - majorR) * pNear.z / sqrtXZ1
    ));

    float sqrtXZ2 = sqrt(pFar.x * pFar.x + pFar.z * pFar.z + 1e-8);
    normalFar = normalize(vec3(
        (sqrtXZ2 - majorR) * pFar.x / sqrtXZ2,
        pFar.y,
        (sqrtXZ2 - majorR) * pFar.z / sqrtXZ2
    ));

    return true;
}

// ============================================================================
// Bezier Instance SDF - Control point metaball approximation
// Creates a "blobby" surface around control points for sphere tracing
// ============================================================================

// Blob radius computed from BVH bounds - cached per frame
float g_blobRadius = 0.0;

// SDF using control points as metaballs (local space)
// Control point offset from surface creates smooth envelope that captures curves
// Returns signed distance: negative inside, positive outside
float patchCloudSDF(vec3 p) {
    float minDist = 1e20;

    // Sample all 16 control points per patch
    // Control points form a "cage" that smoothly envelops the surface
    for (uint i = 0; i < pc.numPatches; i++) {
        uint base = i * 16;
        // All 16 control points
        for (int j = 0; j < 16; j++) {
            minDist = min(minDist, length(p - patchData[base + j].xyz));
        }
    }

    return minDist - g_blobRadius;
}

// Compute SDF gradient for normal calculation
vec3 patchCloudGradient(vec3 p) {
    const float eps = 0.001;
    return normalize(vec3(
        patchCloudSDF(p + vec3(eps, 0, 0)) - patchCloudSDF(p - vec3(eps, 0, 0)),
        patchCloudSDF(p + vec3(0, eps, 0)) - patchCloudSDF(p - vec3(0, eps, 0)),
        patchCloudSDF(p + vec3(0, 0, eps)) - patchCloudSDF(p - vec3(0, 0, eps))
    ));
}

// ============================================================================
// Bezier Instance SDF hit - Bidirectional sphere tracing
// Uses control point cloud for teapot-like caustic shapes
// ============================================================================
bool hitInstanceSDF(uint instIdx, vec3 ro, vec3 rd,
                    out float tNear, out float tFar,
                    out vec3 normalNear, out vec3 normalFar,
                    out vec3 worldEntry, out vec3 worldExit) {
    if (pc.numBVHNodes == 0 || pc.numPatches == 0) return false;

    BezierInstance inst = instances[instIdx];

    // Transform ray to local space
    vec3 localOrigin = rotateXYZInverse(ro - inst.position, inst.rotation) / inst.scale;
    vec3 localDir = normalize(rotateXYZInverse(rd, inst.rotation));

    // Get bounds from BVH root node (local space) for bounding sphere
    vec3 aabbMin = vec3(bvhNodes[0].minX, bvhNodes[0].minY, bvhNodes[0].minZ);
    vec3 aabbMax = vec3(bvhNodes[0].maxX, bvhNodes[0].maxY, bvhNodes[0].maxZ);
    vec3 aabbCenter = (aabbMin + aabbMax) * 0.5;
    float boundRadius = length(aabbMax - aabbMin) * 0.6;  // Bounding sphere

    // Compute blob radius from bounds (control point spacing)
    // Larger radius = fuller coverage, smaller = tighter/sharper fit
    g_blobRadius = length(aabbMax - aabbMin) * 0.12;  // ~12% of diagonal

    // Bounding sphere check
    vec3 oc = localOrigin - aabbCenter;
    float b = dot(oc, localDir);
    float c = dot(oc, oc) - boundRadius * boundRadius;
    float disc = b * b - c;
    if (disc < 0.0) return false;

    float sqrtDisc = sqrt(disc);
    float t0 = -b - sqrtDisc;
    float t1 = -b + sqrtDisc;
    if (t1 < 0.001) return false;

    float tStart = max(t0, 0.001);
    float tEnd = t1;

    // Forward sphere trace to find entry
    tNear = -1.0;
    float t = tStart;
    for (int i = 0; i < 64; i++) {
        vec3 p = localOrigin + t * localDir;
        float d = patchCloudSDF(p);
        if (d < 0.0005) {
            tNear = t;
            break;
        }
        t += max(d, 0.005);  // Min step to avoid getting stuck
        if (t > tEnd) break;
    }
    if (tNear < 0.0) return false;

    // Backward sphere trace to find exit
    tFar = -1.0;
    t = tEnd;
    for (int i = 0; i < 64; i++) {
        vec3 p = localOrigin + t * localDir;
        float d = patchCloudSDF(p);
        if (d < 0.0005) {
            tFar = t;
            break;
        }
        t -= max(d, 0.005);
        if (t <= tNear + 0.001) break;
    }

    // Fallback: march forward from entry to find exit
    if (tFar < 0.0 || tFar <= tNear) {
        t = tNear + 0.01;
        bool wasInside = true;
        for (int i = 0; i < 128; i++) {
            vec3 p = localOrigin + t * localDir;
            float d = patchCloudSDF(p);
            if (d > 0.01) {  // Crossed to outside
                // Binary search for exact crossing
                float lo = tNear, hi = t;
                for (int j = 0; j < 12; j++) {
                    float mid = (lo + hi) * 0.5;
                    if (patchCloudSDF(localOrigin + mid * localDir) < 0.0) {
                        lo = mid;
                    } else {
                        hi = mid;
                    }
                }
                tFar = (lo + hi) * 0.5;
                break;
            }
            t += 0.02;
            if (t > tEnd) {
                tFar = tEnd;  // Use bound as fallback
                break;
            }
        }
    }

    if (tFar <= tNear) return false;

    // Compute normals from SDF gradient (local space)
    vec3 pNear = localOrigin + tNear * localDir;
    vec3 pFar = localOrigin + tFar * localDir;
    vec3 localNormalNear = patchCloudGradient(pNear);
    vec3 localNormalFar = patchCloudGradient(pFar);

    // Transform normals back to world space
    normalNear = normalize(rotateXYZ(localNormalNear, inst.rotation));
    normalFar = normalize(rotateXYZ(localNormalFar, inst.rotation));

    // Transform hit points to world space
    worldEntry = rotateXYZ(pNear * inst.scale, inst.rotation) + inst.position;
    worldExit = rotateXYZ(pFar * inst.scale, inst.rotation) + inst.position;

    // Adjust t values for world-space distance
    tNear = length(worldEntry - ro);
    tFar = length(worldExit - ro);

    return true;
}

// Trace ray against opaque (non-dielectric) geometry
// Returns hit position or vec3(-1000) sentinel if no hit
vec3 traceToOpaqueGeometry(vec3 ro, vec3 rd, float maxDist) {
    float bestT = maxDist;

    for (uint i = 0; i < pc.numPrimitives; i++) {
        uint primMatId = primMaterialIds[i];
        if (primMatId >= pc.numMaterials) continue;
        // Skip refractive materials (IOR > 1.0) - we want opaque surfaces only
        if (materials[primMatId].ior > 1.001) continue;

        CSGPrimitive prim = primitives[i];
        CSGTransform xform = transforms[i];
        vec3 center = vec3(prim.x, prim.y, prim.z);
        float scale = xform.scale;

        float t = -1.0;
        if (prim.type == PRIM_SPHERE) {
            t = hitSphere(ro, rd, center, prim.param0 * scale);
        } else if (prim.type == PRIM_BOX) {
            vec3 half_ = vec3(prim.param0, prim.param1, prim.param2) * scale;
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitBox(ro, rd, center, half_, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_CYLINDER) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitCylinder(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_CONE) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitCone(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_TORUS) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitTorus(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        }

        if (t > 0.001 && t < bestT) {
            bestT = t;
        }
    }

    // Also check floor if enabled
    if (pc.floorY > -1000.0 && abs(rd.y) > 0.001) {
        float tFloor = (pc.floorY - ro.y) / rd.y;
        if (tFloor > 0.001 && tFloor < bestT) {
            bestT = tFloor;
        }
    }

    if (bestT >= maxDist) {
        return vec3(-1000.0);  // No hit
    }

    return ro + rd * bestT;
}

// Trace ray through dielectric, return surface hit position (vec3(-1000) if no hit)
// Also returns: primitive index, path length through dielectric, material ID
vec3 tracePhoton(vec3 ro, vec3 rd, out int hitPrimitive, out float pathLength, out uint matId) {
    hitPrimitive = -1;
    pathLength = 0.0;
    matId = 0;

    // DEBUG: Check if we have primitives at all
    if (pc.numPrimitives == 0) {
        return vec3(-1000.0);
    }

    // Find closest dielectric object (CSG primitive or Bezier instance)
    float bestT = 1e10;
    int bestPrim = -1;
    int bestInstance = -1;  // -1 = CSG primitive, >= 0 = Bezier instance index

    // Check CSG primitives for dielectrics (IOR > 1.0)
    for (uint i = 0; i < pc.numPrimitives; i++) {
        uint primMatId = primMaterialIds[i];
        if (primMatId >= pc.numMaterials) continue;
        // Dielectrics have real IOR > 1.0 (default is 1.0 = no refraction)
        float ior = materials[primMatId].ior;
        if (ior <= 1.001) continue;

        CSGPrimitive prim = primitives[i];
        CSGTransform xform = transforms[i];
        vec3 center = vec3(prim.x, prim.y, prim.z);
        float scale = xform.scale;

        float t = -1.0;
        if (prim.type == PRIM_SPHERE) {
            t = hitSphere(ro, rd, center, prim.param0 * scale);
        } else if (prim.type == PRIM_BOX) {
            vec3 half_ = vec3(prim.param0, prim.param1, prim.param2) * scale;
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitBox(ro, rd, center, half_, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_CYLINDER) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitCylinder(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_CONE) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitCone(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        } else if (prim.type == PRIM_TORUS) {
            float tNear, tFar;
            vec3 nNear, nFar;
            if (hitTorus(ro, rd, center, prim.param0 * scale, prim.param1 * scale, tNear, tFar, nNear, nFar)) {
                t = tNear;
            }
        }

        if (t > 0.0 && t < bestT) {
            bestT = t;
            bestPrim = int(i);
            bestInstance = -1;  // CSG primitive
        }
    }

    // Check Bezier instances (dielectric teapots, etc.)
    for (uint i = 0; i < pc.numInstances; i++) {
        BezierInstance inst = instances[i];
        if (inst.materialId >= pc.numMaterials) continue;
        // Dielectrics have real IOR > 1.0
        if (materials[inst.materialId].ior <= 1.001) continue;

        float tNear, tFar;
        vec3 nNear, nFar, wEntry, wExit;
        if (hitInstanceSDF(i, ro, rd, tNear, tFar, nNear, nFar, wEntry, wExit)) {
            if (tNear > 0.0 && tNear < bestT) {
                bestT = tNear;
                bestPrim = int(i);
                bestInstance = int(i);  // Bezier instance
            }
        }
    }

    if (bestPrim < 0 && bestInstance < 0) return vec3(-1000.0);  // Sentinel for "no hit"

    hitPrimitive = bestPrim;

    // Get material ID based on hit type
    if (bestInstance >= 0) {
        matId = instances[bestInstance].materialId;
    } else {
        matId = primMaterialIds[bestPrim];
    }

    // Trace through dielectric
    float ior = materials[matId].ior > 1.0 ? materials[matId].ior : 1.5;

    vec3 hitEntry, hitExit;
    vec3 normalEntry, normalExit;
    vec3 refracted;

    // Handle Bezier instance (dielectric teapot, etc.) using SDF sphere tracing
    if (bestInstance >= 0) {
        float tNear, tFar;
        vec3 nNear, nFar, wEntry, wExit;
        hitInstanceSDF(uint(bestInstance), ro, rd, tNear, tFar, nNear, nFar, wEntry, wExit);

        hitEntry = wEntry;
        normalEntry = nNear;

        refracted = refractRay(rd, normalEntry, 1.0 / ior);
        if (length(refracted) < 0.5) return vec3(-1000.0);

        // Re-trace with refracted ray to find exit point
        float tN2, tF2;
        vec3 nN2, nF2, wE2, wX2;
        if (!hitInstanceSDF(uint(bestInstance), hitEntry + refracted * 0.01, refracted,
                             tN2, tF2, nN2, nF2, wE2, wX2)) {
            // Fallback: use original exit point
            hitExit = wExit;
            normalExit = nFar;
        } else {
            hitExit = wX2;
            normalExit = nF2;
        }

        hitExit = hitExit + normalExit * 0.001;  // Push slightly outside
    }
    // Handle CSG primitives
    else {
        CSGPrimitive prim = primitives[bestPrim];
        CSGTransform xform = transforms[bestPrim];
        vec3 center = vec3(prim.x, prim.y, prim.z);
        float scale = xform.scale;

        hitEntry = ro + rd * bestT;

        if (prim.type == PRIM_SPHERE) {
            float radius = prim.param0 * scale;
            normalEntry = normalize(hitEntry - center);

            refracted = refractRay(rd, normalEntry, 1.0 / ior);
            if (length(refracted) < 0.5) return vec3(-1000.0);

            float tExit = hitSphereFar(hitEntry + refracted * 0.001, refracted, center, radius);
            if (tExit < 0.0) return vec3(-1000.0);

            hitExit = hitEntry + refracted * (tExit + 0.001);
            normalExit = normalize(hitExit - center);
        } else if (prim.type == PRIM_BOX) {
            vec3 half_ = vec3(prim.param0, prim.param1, prim.param2) * scale;
            float tNear, tFar;
            vec3 nNear, nFar;
            hitBox(ro, rd, center, half_, tNear, tFar, nNear, nFar);
            normalEntry = nNear;

            refracted = refractRay(rd, normalEntry, 1.0 / ior);
            if (length(refracted) < 0.5) return vec3(-1000.0);

            // Use slab intersection for refracted ray exit
            vec3 invRef = 1.0 / (refracted + vec3(1e-8));
            vec3 t1 = (center - half_ - hitEntry) * invRef;
            vec3 t2 = (center + half_ - hitEntry) * invRef;
            vec3 tMax = max(t1, t2);
            float tExit = min(min(tMax.x, tMax.y), tMax.z);

            if (tExit < 0.001) return vec3(-1000.0);

            hitExit = hitEntry + refracted * tExit;

            // Exit normal from position
            vec3 local = hitExit - center;
            vec3 normHalf = abs(local) / half_;
            if (normHalf.x >= normHalf.y && normHalf.x >= normHalf.z) {
                normalExit = vec3(sign(local.x), 0.0, 0.0);
            } else if (normHalf.y >= normHalf.z) {
                normalExit = vec3(0.0, sign(local.y), 0.0);
            } else {
                normalExit = vec3(0.0, 0.0, sign(local.z));
            }

            hitExit = hitExit + normalExit * 0.001;
        } else if (prim.type == PRIM_CYLINDER) {
            float radius = prim.param0 * scale;
            float height = prim.param1 * scale;
            float tNear, tFar;
            vec3 nNear, nFar;
            hitCylinder(ro, rd, center, radius, height, tNear, tFar, nNear, nFar);
            normalEntry = nNear;

            refracted = refractRay(rd, normalEntry, 1.0 / ior);
            if (length(refracted) < 0.5) return vec3(-1000.0);

            float tN2, tF2;
            vec3 nN2, nF2;
            if (!hitCylinder(hitEntry + refracted * 0.01, refracted, center, radius, height, tN2, tF2, nN2, nF2)) {
                return vec3(-1000.0);
            }

            hitExit = hitEntry + refracted * (tF2 + 0.01);
            normalExit = nF2;
        } else if (prim.type == PRIM_CONE) {
            float radius = prim.param0 * scale;
            float height = prim.param1 * scale;
            float tNear, tFar;
            vec3 nNear, nFar;
            hitCone(ro, rd, center, radius, height, tNear, tFar, nNear, nFar);
            normalEntry = nNear;

            refracted = refractRay(rd, normalEntry, 1.0 / ior);
            if (length(refracted) < 0.5) return vec3(-1000.0);

            float tN2, tF2;
            vec3 nN2, nF2;
            if (!hitCone(hitEntry + refracted * 0.01, refracted, center, radius, height, tN2, tF2, nN2, nF2)) {
                return vec3(-1000.0);
            }

            hitExit = hitEntry + refracted * (tF2 + 0.01);
            normalExit = nF2;
        } else if (prim.type == PRIM_TORUS) {
            float majorR = prim.param0 * scale;
            float minorR = prim.param1 * scale;
            float tNear, tFar;
            vec3 nNear, nFar;
            hitTorus(ro, rd, center, majorR, minorR, tNear, tFar, nNear, nFar);
            normalEntry = nNear;

            refracted = refractRay(rd, normalEntry, 1.0 / ior);
            if (length(refracted) < 0.5) return vec3(-1000.0);

            float tN2, tF2;
            vec3 nN2, nF2;
            if (!hitTorus(hitEntry + refracted * 0.01, refracted, center, majorR, minorR, tN2, tF2, nN2, nF2)) {
                return vec3(-1000.0);
            }

            hitExit = hitEntry + refracted * (tF2 + 0.01);
            normalExit = nF2;
        } else {
            return vec3(-1000.0);  // Unknown primitive type
        }
    }  // End of CSG primitive handling

    // Calculate path length through dielectric for Beer's law
    pathLength = length(hitExit - hitEntry);

    // Refract out
    vec3 exitDir = refractRay(refracted, -normalExit, ior);
    if (length(exitDir) < 0.5) return vec3(-1000.0);
    exitDir = normalize(exitDir);

    // Trace to opaque geometry (any non-dielectric surface)
    vec3 geoHit = traceToOpaqueGeometry(hitExit + exitDir * 0.01, exitDir, 100.0);

    // DEBUG: If geometry trace fails, try simple y=0 plane to verify photons work
    if (geoHit.x < -100.0 && exitDir.y < -0.001) {
        float tPlane = -hitExit.y / exitDir.y;
        if (tPlane > 0.0 && tPlane < 100.0) {
            geoHit = hitExit + exitDir * tPlane;
        }
    }

    // Fallback: use dielectric exit point projected to y=0
    if (geoHit.x < -100.0) {
        geoHit = vec3(hitExit.x, 0.0, hitExit.z);
    }

    return geoHit;
}

void main() {
    ivec2 rayIdx = ivec2(gl_GlobalInvocationID.xy);
    if (rayIdx.x >= int(pc.gridWidth) || rayIdx.y >= int(pc.gridHeight)) return;

    // Normalized grid coordinates [-1, 1]
    float u = (float(rayIdx.x) / float(pc.gridWidth - 1)) * 2.0 - 1.0;
    float v = (float(rayIdx.y) / float(pc.gridHeight - 1)) * 2.0 - 1.0;

    vec3 lightDir = normalize(vec3(pc.lightDirX, pc.lightDirY, pc.lightDirZ));
    vec3 lightPos = vec3(pc.lightPosX, pc.lightPosY, pc.lightPosZ);

    // Build orthonormal basis for light
    vec3 up = abs(lightDir.y) > 0.99 ? vec3(1, 0, 0) : vec3(0, 1, 0);
    vec3 right = normalize(cross(up, lightDir));
    vec3 forward = cross(lightDir, right);

    vec3 ro, rd;
    float raySpacing;

    if (pc.lightType == LIGHT_DIRECTIONAL) {
        // Directional: parallel rays covering area around camera
        float extent = 50.0;  // Cover ±50 world units around camera
        raySpacing = extent * 2.0 / float(pc.gridWidth);

        // Build ray grid perpendicular to light direction, centered on camera XZ
        // This focuses caustic computation where the camera is looking
        vec3 camPos = vec3(pc.camPosX, pc.camPosY, pc.camPosZ);
        vec3 gridCenter = vec3(camPos.x, 0.0, camPos.z);  // Project camera to Y=0 plane
        float startDist = 200.0;  // Start far back along light direction

        // Grid is in the plane perpendicular to lightDir
        ro = gridCenter - lightDir * startDist + right * u * extent + forward * v * extent;
        rd = lightDir;
    } else if (pc.lightType == LIGHT_POINT) {
        // Point light: rays emanate from point in hemisphere toward floor
        float angle = 0.8;  // Cone half-angle
        rd = normalize(lightDir + right * u * angle + forward * v * angle);
        ro = lightPos;
        raySpacing = angle * 2.0 / float(pc.gridWidth);
    } else {
        // Spot light: rays within cone
        float angle = pc.lightRadius;  // Cone half-angle in radians
        rd = normalize(lightDir + right * u * angle + forward * v * angle);
        ro = lightPos;
        raySpacing = angle * 2.0 / float(pc.gridWidth);
    }

    // Trace center ray (returns vec3(-1000) for no hit)
    int primCenter, primRight, primUp;
    float pathCenter, pathRight, pathUp;
    uint matCenter, matRight, matUp;
    vec3 hitCenter = tracePhoton(ro, rd, primCenter, pathCenter, matCenter);

    if (hitCenter.x < -100.0) return;  // Check for sentinel, not negative coords

    // 3D spatial hash handles any position - no bounds check needed

    // Compute area ratio using neighboring rays
    // For directional light with XZ grid, neighbors are simply +X and +Z
    vec3 roRight = (pc.lightType == LIGHT_DIRECTIONAL) ? ro + vec3(raySpacing, 0.0, 0.0) : ro + right * raySpacing;
    vec3 roUp = (pc.lightType == LIGHT_DIRECTIONAL) ? ro + vec3(0.0, 0.0, raySpacing) : ro + forward * raySpacing;

    // For point/spot, direction also changes
    vec3 rdRight = rd, rdUp = rd;
    if (pc.lightType != LIGHT_DIRECTIONAL) {
        float du = 1.0 / float(pc.gridWidth - 1) * 2.0;
        float angle = (pc.lightType == LIGHT_SPOT) ? pc.lightRadius : 0.8;
        rdRight = normalize(lightDir + right * (u + du) * angle + forward * v * angle);
        rdUp = normalize(lightDir + right * u * angle + forward * (v + du) * angle);
    }

    vec3 hitRight = tracePhoton(roRight, rdRight, primRight, pathRight, matRight);
    vec3 hitUp = tracePhoton(roUp, rdUp, primUp, pathUp, matUp);

    // Require all 3 rays to trace through dielectric (can be different primitives)
    if (hitRight.x < -100.0 || hitUp.x < -100.0) {
        return;  // Neighbor missed dielectric entirely
    }

    // Check floor position continuity - reject if neighbors land too far apart
    // This catches face transitions within a single primitive (esp. boxes)
    // where neighboring rays hit different faces and refract very differently
    float distRight = length(hitRight - hitCenter);
    float distUp = length(hitUp - hitCenter);
    float maxDist = raySpacing * 5.0;  // Allow some focusing but reject discontinuities
    if (distRight > maxDist || distUp > maxDist) {
        return;  // Floor positions too far apart - likely face transition artifact
    }

    // Compute area compression
    vec3 dRight = hitRight - hitCenter;
    vec3 dUp = hitUp - hitCenter;
    float refractedArea = length(cross(dRight, dUp));

    float origArea = raySpacing * raySpacing;

    // Filter out degenerate cases (extreme focusing or divergence)
    if (refractedArea < 0.0001 || refractedArea > origArea * 100.0) {
        return;  // Skip outliers that would create bright dots
    }

    float intensity = origArea / refractedArea;
    intensity = clamp(intensity, 0.0, 10.0);  // Tighter clamp to avoid hotspots

    // For point/spot lights, also apply distance falloff
    if (pc.lightType != LIGHT_DIRECTIONAL) {
        float dist = length(hitCenter - lightPos);
        intensity /= (1.0 + dist * dist * 0.01);
    }

    // Apply Beer's law for colored dielectric absorption
    // absorption = -log(color) gives us absorption coefficient from transmission color
    // transmitted = exp(-absorption * distance)
    Material mat = materials[matCenter];
    vec3 tintColor = vec3(mat.r, mat.g, mat.b);

    // Convert color to absorption (avoid log(0) with small epsilon)
    // Higher color value = less absorption = more transmission
    vec3 absorption = -log(max(tintColor, vec3(0.01)));

    // Apply Beer's law: transmission decreases exponentially with path length
    // Scale path length for reasonable absorption (typical sphere diameter ~2)
    float absorptionScale = 0.5;  // Tunable: higher = more color saturation
    vec3 transmission = exp(-absorption * pathCenter * absorptionScale);

    // Compute RGB contribution (scale for fixed-point storage)
    vec3 rgbContribution = transmission * intensity * pc.lightIntensity * 1000.0;
    uvec3 fixedRGB = uvec3(clamp(rgbContribution, vec3(0.0), vec3(1000000.0)));

    if (fixedRGB.r == 0u && fixedRGB.g == 0u && fixedRGB.b == 0u) return;

    // Atomic accumulate RGB to 3D spatial hash with collision validation
    // Buffer layout: 4 uints per cell [signature, R, G, B]
    ivec3 cell = causticGetCell3D(hitCenter);
    uint hash = cellHash3D(cell);
    uint sig = cellSignature(cell);

    // Try to claim this bucket with our cell signature
    // atomicCompSwap returns old value: 0 means we claimed it, sig means same cell owns it
    uint oldSig = atomicCompSwap(causticCells[hash * 4u + 0u], 0u, sig);

    if (oldSig == 0u || oldSig == sig) {
        // Bucket is ours (first claim) or same cell already owns it - add RGB
        atomicAdd(causticCells[hash * 4u + 1u], fixedRGB.r);
        atomicAdd(causticCells[hash * 4u + 2u], fixedRGB.g);
        atomicAdd(causticCells[hash * 4u + 3u], fixedRGB.b);
    }
    // else: collision with different cell, skip this photon (prevents disco floor)
}
